<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Important options · TreeKnit documentation</title><meta name="title" content="Important options · TreeKnit documentation"/><meta property="og:title" content="Important options · TreeKnit documentation"/><meta property="twitter:title" content="Important options · TreeKnit documentation"/><meta name="description" content="Documentation for TreeKnit documentation."/><meta property="og:description" content="Documentation for TreeKnit documentation."/><meta property="twitter:description" content="Documentation for TreeKnit documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TreeKnit documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li class="is-active"><a class="tocitem" href>Important options</a><ul class="internal"><li><a class="tocitem" href="#gamma"><span>Parsimony parameter</span></a></li><li><a class="tocitem" href="#Resolving-trees-with-polytomies"><span>Resolving trees with polytomies</span></a></li><li><a class="tocitem" href="#likelihood"><span>Degeneracy: sorting with likelihood</span></a></li><li><a class="tocitem" href="#Verbosity"><span>Verbosity</span></a></li></ul></li><li><a class="tocitem" href="../multitreeknit/">MultiTreeKnit</a></li><li><a class="tocitem" href="../visualization/">Visualizing MCCs</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">Objects</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href>Important options</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Important options</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/PierreBarrat/TreeKnit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/PierreBarrat/TreeKnit.jl/blob/master/docs/src/options.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="options"><a class="docs-heading-anchor" href="#options">Options</a><a id="options-1"></a><a class="docs-heading-anchor-permalink" href="#options" title="Permalink"></a></h1><p><code>run_treeknit!</code> uses a topogy based heuristic optimization to find maximally compatible clades.    Options to this heuristic are provided through the <code>OptArgs</code> object, that is optionally passed as a second argument.   Essential options are detailed here. 	</p><p>Note that when the <code>OptArgs()</code> object is initialized it&#39;s default parameters are the same as those for running <code>TreeKnit</code> for 2 trees. When instead the constructor <code>OptArgs(K::Int)</code> is called, the default parameters for running <code>TreeKnit</code> with <code>K</code> trees are returned. </p><p>The default parameters for <code>K=2</code> trees are the parameters for the <code>:better_MCCs</code> method, whereas the default parameters for <code>K&gt;2</code> trees are the parameters for the <code>:better_trees</code> method. See <a href="../overview/#TK_method_options">TreeKnit Methods</a>.</p><h2 id="gamma"><a class="docs-heading-anchor" href="#gamma">Parsimony parameter</a><a id="gamma-1"></a><a class="docs-heading-anchor-permalink" href="#gamma" title="Permalink"></a></h2><p>The heuristic method used by <em>TreeKnit</em> tries to prune consistent clades from a pair of trees in order to increase a compatibility score between other clades.    Pruning a clade is interpreted as fixing a reassortment right above it, while increasing the compatibility between remaining clades removes reassortments.    A purely parsimonious heuristic should thus give the same weight to fixing a reassortment through pruning a clade and fixing one incompatibility in the trees. </p><p>Here, we assign the score <span>$\gamma$</span> to each pruned clade, and count as <span>$1$</span> each incompatibility fixed for the remaining clades.    For <span>$\gamma=1$</span>, we obtain a parsimonious method that attempts to minimize the overall number of reassortments.    For higher values, pruning a clade must &quot;fix&quot; at least <span>$\gamma$</span> incompatibilities to be considered a good move, making the obtained MCCs less parsimonious.    For infinite <span>$\gamma$</span>, pruning clades is impossible, and we fall back on the <a href="../mccs/#naive_mccs">naive estimation of MCCs</a>. </p><p>The example below illustrates the difference between different <span>$\gamma$</span> values: </p><pre><code class="language-julia hljs">t1 = parse_newick_string(&quot;((((A,B),C),D),E);&quot;; label=&quot;t1&quot;)
t2 = parse_newick_string(&quot;((((D,B),E),A),C);&quot;; label=&quot;t2&quot;) # Same topology, but shuffled leave</code></pre><p>Here, pruning the two leaves <code>(A,C)</code> or <code>(D,E)</code> results in compatible trees (resp. <code>((B,D),E)</code> and <code>((A,B),C)</code>).    These moves each have a cost 2<span>$\gamma$</span> (removing 2 clades), but bring us from trees with 5 incompatibilities to 0.    They will only be accepted if <span>$\gamma \leq 2.5$</span>. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; run_treeknit!(t1, t2, OptArgs(γ=2))</code><code class="nohighlight hljs ansi" style="display:block;">MCC_set(2, [&quot;t1&quot;, &quot;t2&quot;], Dict{Set{String}, Vector{Vector{String}}}(Set([&quot;t2&quot;, &quot;t1&quot;]) =&gt; [[&quot;D&quot;], [&quot;E&quot;], [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; run_treeknit!(t1, t2, OptArgs(γ=3))</code><code class="nohighlight hljs ansi" style="display:block;">MCC_set(2, [&quot;t1&quot;, &quot;t2&quot;], Dict{Set{String}, Vector{Vector{String}}}(Set([&quot;t2&quot;, &quot;t1&quot;]) =&gt; [[&quot;A&quot;], [&quot;B&quot;], [&quot;C&quot;], [&quot;D&quot;], [&quot;E&quot;]]))</code></pre><h2 id="Resolving-trees-with-polytomies"><a class="docs-heading-anchor" href="#Resolving-trees-with-polytomies">Resolving trees with polytomies</a><a id="Resolving-trees-with-polytomies-1"></a><a class="docs-heading-anchor-permalink" href="#Resolving-trees-with-polytomies" title="Permalink"></a></h2><p>See <a href="../resolving/#resolving">Resolving</a> for more information about tree resolution. Note we have multiple options for resolving trees:</p><ul><li><code>pre_resolve:</code> if this option is passed to <code>run_treeknit!</code> (through <code>OptArgs</code>), <code>resolve!</code> will be called on all trees <strong>together</strong> prior to MCC inference. </li><li><code>resolve:</code> under this option <code>resolve!</code> is called on each <strong>pair</strong> of trees before each iteration of the MCC inference procedure. For example if treeknit is run on trees <code>t1</code>, <code>t2</code> and <code>t3</code> and <code>resolve</code> is set to <code>true</code>, <code>resolve!</code> will be called on each combination of tree pairs (see <a href="../multitreeknit/#multitreeknit">MultiTreeKnit</a> for more details).  Furthermore, this option allows for tree resolution during MCC inference on tree pairs and will resolve trees after each pair-wise iteration of <code>TreeKnit</code> using the inferred MCCs.</li></ul><div class="admonition is-info"><header class="admonition-header">pre-resolve and resolve for tree pairs</header><div class="admonition-body"><p>Note that<code>resolve=true</code> will also resolve trees with each other prior to inference, and thus <code>pre_resolve</code> is not needed for 2 trees if <code>resolve=true</code>, but we distinguish between the two options for consistency with <span>$&gt;2$</span> trees).</p></div></div><p>When resolving trees using MCCs we distinguish between two options (see <a href="../resolving/#resolve_strict_vs_liberal">strict vs liberal resolution</a> for a detailed description of the two methods):</p><ul><li><code>strict=true:</code> only add unambiguous splits from one tree into another.</li><li><code>strict=false</code> also known as <code>liberal</code> resolve: will resolve trees as much as possible, fully resolving shared regions of the two trees, but arbitrarily choosing the location of ambiguous splits, leading to potentially wrong splits in the output trees. </li></ul><h2 id="likelihood"><a class="docs-heading-anchor" href="#likelihood">Degeneracy: sorting with likelihood</a><a id="likelihood-1"></a><a class="docs-heading-anchor-permalink" href="#likelihood" title="Permalink"></a></h2><p>When several MCC decompositions are possible, degeneracy is removed by using the <code>likelihood_sort</code> option (activated by default).  In the example below, there are three equivalent decompositions if only topology is considered: </p><pre><code class="language-julia hljs">t1 = parse_newick_string(&quot;((A:2,B:2):2,C:4);&quot;)
t2 = parse_newick_string(&quot;(A:2,(B:1,C:1):1);&quot;)
oa = OptArgs(likelihood_sort = false)
unique([run_treeknit!(t1, t2, oa).mccs[Set([t1.label, t2.label])] for rep in 1:50]) # Repeating computation many times</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{Vector{String}}}:
 [[&quot;A&quot;], [&quot;B&quot;, &quot;C&quot;]]
 [[&quot;B&quot;], [&quot;A&quot;, &quot;C&quot;]]
 [[&quot;C&quot;], [&quot;A&quot;, &quot;B&quot;]]</code></pre><p>When taking branch lengths into account, this degeneracy vanishes: </p><pre><code class="language-julia hljs">oa = OptArgs(likelihood_sort = true)
unique([run_treeknit!(t1, t2, oa).mccs[Set([t1.label, t2.label])] for rep in 1:50])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Vector{Vector{String}}}:
 [[&quot;C&quot;], [&quot;A&quot;, &quot;B&quot;]]
 [[&quot;B&quot;], [&quot;A&quot;, &quot;C&quot;]]</code></pre><h2 id="Verbosity"><a class="docs-heading-anchor" href="#Verbosity">Verbosity</a><a id="Verbosity-1"></a><a class="docs-heading-anchor-permalink" href="#Verbosity" title="Permalink"></a></h2><p>The TreeKnit cli has four level of verbosity that can be set with the <code>--verbosity-level &lt;value&gt;</code> option: </p><ul><li><code>-1</code> means no visible output</li><li><code>0</code> means relatively little output: e.g. input file names, number of MCCs found,... The default options result in less than 10 lines.</li><li><code>1</code> gives slightly more details: e.g. the MCC inference process for each pair of trees is detailed</li><li><code>2</code> gives a lot of information and is only useful for debugging and when using small trees </li></ul><p>The <code>--verbose</code> or <code>-v</code> flag set the verbosity to <code>1</code> instead of <code>0</code>. </p><p>When using from a julia session, it can be useful to also set the verbosity.  Let&#39;s take the simple case where one wants to use <code>run_treeknit!(tree1, tree2, OptArgs())</code> with some pre-loaded trees and default arguments.  If run like this, no info will be shown.  To trigger verbosity, create a custom logger in the following way: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TreeKnit, TreeTools, Logging</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t1 = parse_newick_string(&quot;((A:2,B:2):2,C:4);&quot;; label=&quot;t1&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2 = parse_newick_string(&quot;(A:2,(B:1,C:1):1);&quot;; label=&quot;t2&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; verbosity = 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; logger = ConsoleLogger(LogLevel(-verbosity)) # corresponds to `--verbosity-level 1` from the CLI</code><code class="nohighlight hljs ansi" style="display:block;">Logging.ConsoleLogger(IOBuffer(data=UInt8[...], readable=false, writable=false, seekable=false, append=false, size=0, maxsize=0, ptr=1, mark=-1), LogLevel(-1), Logging.default_metafmt, true, 0, Dict{Any, Int64}())</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; output = with_logger(logger) do
         run_treeknit!(t1, t2, OptArgs())
       end</code><code class="nohighlight hljs ansi" style="display:block;">┌ LogLevel(-1): ROUND: 1
│ 
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:37
┌ LogLevel(-1): Infering MCCs for trees: t2 and t1
│ 
│ 
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:49
┌ LogLevel(-1): Initial state: 3 naive MCCs
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:216
┌ LogLevel(-1): --- Iteration 1 (max. 15) - 3 leaves remaining ---
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:221
┌ LogLevel(-1): Running optimization to find MCCs...
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:224
┌ LogLevel(-1): Cooling schedule: geometric / Temperature values: 101 / Total of MCMC steps: 150
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:225
┌ LogLevel(-1): Sorting 3 topologically equivalent configurations.
└ @ TreeKnit.SplitGraph ~/work/TreeKnit.jl/TreeKnit.jl/src/SplitGraph/SplitGraph.jl:56
┌ LogLevel(-1): Found 1 new mccs.
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:239
┌ LogLevel(-1): Proceeding based on newly found MCCs...
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:243
┌ LogLevel(-1): Found mccs do not cover all leaves. Pruning them from trees.
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:294
┌ LogLevel(-1): Resulting trees are compatible: final decomposition found. Stopping.
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:304
┌ LogLevel(-1): found MCCs for trees: t2 and t1
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:58
┌ LogLevel(-1): ladderized and sorted trees: t2 and t1
└ @ TreeKnit ~/work/TreeKnit.jl/TreeKnit.jl/src/main.jl:67
MCC_set(2, [&quot;t1&quot;, &quot;t2&quot;], Dict{Set{String}, Vector{Vector{String}}}(Set([&quot;t2&quot;, &quot;t1&quot;]) =&gt; [[&quot;C&quot;], [&quot;A&quot;, &quot;B&quot;]]))</code></pre><p>The above works because during inference, TreeKnit emits log messages in the form <code>@logmsg LogLevel(0/-1/-2) msg</code>.  The default Julia logger will only show messages with a positive level, and this can be set as described above.  See the <a href="https://docs.julialang.org/en/v1/stdlib/Logging">Logging</a> and the <a href="https://github.com/JuliaLogging/LoggingExtras.jl">LoggingExtras</a> package for more information. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mccs/">« MCCs</a><a class="docs-footer-nextpage" href="../multitreeknit/">MultiTreeKnit »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 9 August 2024 11:10">Friday 9 August 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
