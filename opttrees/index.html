<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>opttrees · TreeKnit documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TreeKnit documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li class="is-active"><a class="tocitem" href><code>opttrees</code></a><ul class="internal"><li><a class="tocitem" href="#Coarse-graining-of-naive-MCCs"><span>Coarse-graining of naive MCCs</span></a></li><li><a class="tocitem" href="#The-SplitGraph-object"><span>The <code>SplitGraph</code> object</span></a></li><li><a class="tocitem" href="#Counting-incompatibilities"><span>Counting incompatibilities</span></a></li><li><a class="tocitem" href="#Simulated-annealing"><span>Simulated annealing</span></a></li></ul></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">OptArgs</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Under the hood</a></li><li class="is-active"><a href><code>opttrees</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><code>opttrees</code></a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/TreeKnit.jl/blob/master/docs/src/opttrees.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="opttrees"><a class="docs-heading-anchor" href="#opttrees">The <code>opttrees</code> function</a><a id="opttrees-1"></a><a class="docs-heading-anchor-permalink" href="#opttrees" title="Permalink"></a></h1><p>The core of the heuristic <em>TreeKnit</em> is based on happens in the <code>opttrees</code> function, found in the <code>SplitGraph</code> submodule.    Given two trees, <code>opttrees</code> attempts to reconcile them by pruning certain clades.    A quick description of different steps in this function is given here, with the two simple trees below as an example case: </p><pre><code class="language-julia hljs">nwk1 = &quot;(((A1:1,A2:2):2,(B1:2,(B2:1,B3:1):1):2):2,(C1:1,C2:2):4)&quot;;
nwk2 = &quot;((A1:1,A2:2):2,((B1:2,(B2:1,B3:1):1):1,(C1:1,C2:2):1):1)&quot;;
t1 = node2tree(parse_newick(nwk1))
t2 = node2tree(parse_newick(nwk2))</code></pre><p>Trees are not displayed here for space reasons, but you&#39;re encouraged to draw them if you want to follow along! </p><h2 id="Coarse-graining-of-naive-MCCs"><a class="docs-heading-anchor" href="#Coarse-graining-of-naive-MCCs">Coarse-graining of naive MCCs</a><a id="Coarse-graining-of-naive-MCCs-1"></a><a class="docs-heading-anchor-permalink" href="#Coarse-graining-of-naive-MCCs" title="Permalink"></a></h2><p>As a first step, naive MCCs are computed for input trees using the <code>naive_mccs</code> function.    Here, we find three clades that are already compatible between the two trees: </p><pre><code class="language-julia hljs">treelist = Any[t1, t2]
mcc = naive_mccs(treelist)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Any}:
 [&quot;A1&quot;, &quot;A2&quot;]
 [&quot;C1&quot;, &quot;C2&quot;]
 [&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;]</code></pre><p>Trees are then &quot;reduced&quot; to those MCCs: new trees are built where each leaf corresponds to one of the naive MCCs.    The reduced trees have incompatibilities at the leaf level: it is no longer possible to group some of their leaves together in a consistent clade.  </p><pre><code class="language-julia hljs">mcc_names = TreeKnit.name_mcc_clades!(treelist, mcc)
for (i,t) in enumerate(treelist)
	treelist[i] = TreeKnit.reduce_to_mcc(t, mcc)
end</code></pre><p>The trees in <code>treelist</code> are now a reduced form of <code>t1</code> and <code>t2</code>, and the names of the new leaves correspond to clades in the original tree.    The mapping between leaf name and original clade is stored in <code>mcc_names</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; treelist[1]</code><code class="nohighlight hljs ansi" style="display:block;">
                                      ____________________________________ MCC_1
  ___________________________________|
_|                                   |____________________________________ MCC_3
 |
 |________________________________________________________________________ MCC_2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; treelist[2]</code><code class="nohighlight hljs ansi" style="display:block;">
  ________________________________________________________________________ MCC_1
_|
 |                                    ____________________________________ MCC_3
 |___________________________________|
                                     |____________________________________ MCC_2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mcc_names</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Any, Any} with 3 entries:
  &quot;MCC_2&quot; =&gt; [&quot;C1&quot;, &quot;C2&quot;]
  &quot;MCC_3&quot; =&gt; [&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;]
  &quot;MCC_1&quot; =&gt; [&quot;A1&quot;, &quot;A2&quot;]</code></pre><h2 id="The-SplitGraph-object"><a class="docs-heading-anchor" href="#The-SplitGraph-object">The <code>SplitGraph</code> object</a><a id="The-SplitGraph-object-1"></a><a class="docs-heading-anchor-permalink" href="#The-SplitGraph-object" title="Permalink"></a></h2><p>Once the trees reduced to their naive MCCs, we construct a <code>SplitGraph</code> object from them. </p><div class="admonition is-info"><header class="admonition-header">*SplitGraph* submodule</header><div class="admonition-body"><p>The <code>SplitGraph</code> type and some of the functions used below are in the <em>SplitGraph</em> submodule of <em>TreeKnit</em>. Access them by calling <code>using TreeKnit.SplitGraph</code> and preceding the calls by <code>SplitGraph.</code></p></div></div><p>The <code>SplitGraph</code> is a directed graph that is based on both trees, and has two kind of nodes: </p><ul><li>leaf nodes correspond to leaves of the trees, and are identifier by integers.  They have as many ancestors as there are trees in the <code>SplitGraph</code>. </li><li>internal nodes, called <code>SplitNode</code>s, correspond to internal nodes in one of the two trees. A <code>color::Int</code> attribute identifies the tree to which they belong (<em>e.g.</em> 1 for the first tree, 2 for the second, etc...). They have only one ancestor, of the same color.  Importantly, they are identified by the ensemble of leaf nodes that are &quot;below&quot; them, that is the subset of all their direct and indirect offsprings that are leaves.  As such, they uniquely correspond to a split in one of the two trees.  This information is stored as an array of integer in their <code>conf</code> field. </li></ul><p>Let us know build the <code>SplitGraph</code> object: </p><pre><code class="language-julia hljs">using TreeKnit.SplitGraph
g = SplitGraph.trees2graph(treelist);
g.labels_to_int</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Any, Int64} with 3 entries:
  &quot;MCC_2&quot; =&gt; 1
  &quot;MCC_3&quot; =&gt; 2
  &quot;MCC_1&quot; =&gt; 3</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is recommemded that you add <code>;</code> to the end of lines when working with <code>SplitGraph</code>, <code>SplitNode</code> or <code>LeafNode</code> in the REPL.  If you forget, you will quickly see why :-) </p></div></div><p>We now see that the three leaves from our coarse-grained trees have been attributed an integer index in the <code>SplitGraph</code>.    Let us take a look at the internal nodes above the leaf <code>MCC_3</code>: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a1 = g.leaves[g.labels_to_int[&quot;MCC_3&quot;]].anc[1]; # Ancestor for the first tree</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a2 = g.leaves[g.labels_to_int[&quot;MCC_3&quot;]].anc[2]; # Ancestor for the second tree</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [a1.color, a2.color] # a1 and a2 resp. belong to trees 1 and 2</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a1.conf # list of leaves below `a1`. Among those is the index for &quot;MCC_3&quot;.</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [g.labels[i] for i in a1.conf] # Same as above, with labels</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;MCC_3&quot;
 &quot;MCC_1&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [g.labels[i] for i in a2.conf] # and the same for a2</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;MCC_2&quot;
 &quot;MCC_3&quot;</code></pre><p>We now immediatly see that the internal nodes above <code>MCC_3</code> in the two trees define different splits: <code>(MCC_1, MCC_3)</code> in the first tree is different from <code>(MCC_2, MCC_3)</code> in the second tree.    This is the idea underlying the inference of MCCs. </p><h2 id="Counting-incompatibilities"><a class="docs-heading-anchor" href="#Counting-incompatibilities">Counting incompatibilities</a><a id="Counting-incompatibilities-1"></a><a class="docs-heading-anchor-permalink" href="#Counting-incompatibilities" title="Permalink"></a></h2><p>In the example above, the ancestors of leaf <code>MCC_3</code> in the two trees define different splits: this is called an incompatibility.    Examination of the trees reveals that there are also similar incompatibilitie for the two other leaves <code>MCC_1</code> and <code>MCC_2</code>.    This can be computed using the <code>count_mismatches</code> function: </p><pre><code class="language-julia hljs">SplitGraph.count_mismatches(g)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3</code></pre><p>We indeed find 3 mismatches, one for each leaf. </p><p>However, it is possible to explain the two example trees using less than three reassortments.    What would happen for example if we removed <code>MCC_1</code> from both trees?    The first non-trivial split above leaf <code>MCC_3</code> in both trees would then be <code>(MCC_2, MCC_3)</code>, and the same goes for leaf <code>MCC_2</code>.    The number of incompatibilities would then go down to 0.  &quot;Removing&quot; leaves from the trees, or the graph, is done by defining a <em>configuration</em>: an array of booleans that stores the presence or absence of each leaf.    To remove <code>MCC_1</code>, we simply design a configuration that has <code>0</code> at the index corresponding to <code>MCC_1</code>: </p><pre><code class="language-julia hljs">  conf = ones(Bool, length(g.leaves))
  conf[g.labels_to_int[&quot;MCC_1&quot;]] = false # Remove `MCC_3` from the configuration
  conf</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Bool}:
 1
 1
 0</code></pre><p>To compute the number of incompatibilities given a configuration, we use the <code>compute_energy</code> function. The result is interpreted as the &quot;energy&quot; of this configuration given the graph <code>g</code>: </p><pre><code class="language-julia hljs">SplitGraph.compute_energy(conf, g)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The function <code>count_mismatches(g)</code> shown above is a simple shortcut for </p><pre><code class="language-julia hljs">conf = ones(Bool, length(g.leaves))
SplitGraph.compute_energy(conf, g)</code></pre><p>In other words, it computes the energy for the configuration where all leaves are present. </p></div></div><p>By removing a leaf, <em>i.e.</em> by &quot;enforcing&quot; a reassortment right above it, we&#39;ve reduced the number of incompatibilities for the remaining ones to 0.    Since removing a leaf corresponds to &quot;enforcing&quot; a reassortment, we have to assign a cost to it, that we call <span>$\gamma$</span>.    This defines a score for each configuration, defined as the difference between the energy of the configuration and <span>$\gamma$</span> times the number of leaves that were removed. Depending on the value of <span>$\gamma$</span>, the difference in overall score associated to removing a leaf or keeping it will change from negative to positive.    Scores are computed with the <code>compute_F</code> function that takes <span>$\gamma$</span> as its last argument.   Here are the differences in scores before and after removing <code>MCC_3</code>, for different values of <span>$\gamma$</span>:   </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; conf0 = ones(Bool, length(g.leaves)) # Configuration with all leaves</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Bool}:
 1
 1
 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SplitGraph.compute_F(conf, g, 1) - SplitGraph.compute_F(conf0, g, 1)</code><code class="nohighlight hljs ansi" style="display:block;">-2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SplitGraph.compute_F(conf, g, 2) - SplitGraph.compute_F(conf0, g, 2)</code><code class="nohighlight hljs ansi" style="display:block;">-1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SplitGraph.compute_F(conf, g, 3) - SplitGraph.compute_F(conf0, g, 3)</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SplitGraph.compute_F(conf, g, 4) - SplitGraph.compute_F(conf0, g, 4)</code><code class="nohighlight hljs ansi" style="display:block;">1</code></pre><p>For this simple example, <span>$\gamma = 3$</span> is the &quot;critical&quot; value above which the fact of removing <code>MCC_3</code> or any other leaf is not considered a good move.    The inference of MCCs for <span>$\gamma \leq 3$</span> and <span>$\gamma &gt; 3$</span> will thus give different results.    In the first case, two MCCs will be found, corresponding to one reassortment event (above <code>MCC_3</code> for instance) .    In the second, three MCCs and three reassortments will be found. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; computeMCCs(t1, t2, OptArgs(γ=3.1))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Vector{String}}:
 [&quot;A1&quot;, &quot;A2&quot;]
 [&quot;C1&quot;, &quot;C2&quot;]
 [&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; computeMCCs(t1, t2, OptArgs(γ=2.9))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Vector{String}}:
 [&quot;C1&quot;, &quot;C2&quot;]
 [&quot;A1&quot;, &quot;A2&quot;, &quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;]</code></pre><h2 id="Simulated-annealing"><a class="docs-heading-anchor" href="#Simulated-annealing">Simulated annealing</a><a id="Simulated-annealing-1"></a><a class="docs-heading-anchor-permalink" href="#Simulated-annealing" title="Permalink"></a></h2><p>The <code>opttrees</code> function attempts to find the configuration, <em>i.e.</em> a set of leaves to remove, that minimizes the compatibility score presented above.    Since this is a discrete optimization problem with no clear mathematical formalization, we choose to use the <a href="https://en.wikipedia.org/wiki/Simulated_annealing">simulated annealing</a> technique.  Let us find optimum configurations for our simple trees: </p><pre><code class="language-julia hljs">Trange = reverse(1e-3:1e-2:1) # Cooling schedule
M = 10 # Number of iterations per temperature value
opt_confs = SplitGraph.sa_opt(g; Trange, M, γ = 2)[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{Bool}}:
 [0, 1, 1]
 [1, 1, 0]
 [1, 0, 1]</code></pre><p>We find three optimal configurations, each corresponding to removing one leaf.    This indeed corresponds to the three possible single-reassortment explanations that we could give to reconcile the two trees.    Without branch length information, it is impossible to choose between one of these three optimas: the problem is degenerate.    A likelihood based way to break this degeneracy using branch length is described <a href="../options/#likelihood">here</a>.</p><p>For now, let&#39;s imagine that we have chosen the first optimum configuration as our best solution.    Let&#39;s now map it back on the initial trees: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; removed_leaves = g.labels[.!opt_confs[1]] # Expressed with coarse grained leaves</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{String}:
 &quot;MCC_2&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # `mcc_names` was defined above
       removed_clades = [mcc_names[x] for x in removed_leaves]</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Vector{String}}:
 [&quot;C1&quot;, &quot;C2&quot;]</code></pre><p>What this means is that we have just inferred all elements in <code>removed_clades</code> (just one in our case) to be MCCs.    Of course, in this simple example, it is immediate to see that the other MCC simply consists of all the remaining leaves in the original trees.    This can also be deduced from the fact that the energy of all the optimal configurations is 0.  However, in the general case, some incompatibilities will remain even after simulated annealing.    For this reason, the <code>opttrees</code> function only outputs MCCs that have been identified by having removed them from the tree, <em>i.e.</em> by having enforced a reassortment above their root node.    If the trees that remain after having pruned these MCCs still have incompatibilities, the process described here needs to be <em>iterated</em>.    This is performed by the <code>runopt</code> function. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../options/">« Important options</a><a class="docs-footer-nextpage" href="../runopt/"><code>runopt</code> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 19 December 2022 12:15">Monday 19 December 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
