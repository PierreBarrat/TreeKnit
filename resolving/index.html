<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Resolving · TreeKnit documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TreeKnit documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li class="is-active"><a class="tocitem" href>Resolving</a><ul class="internal"><li><a class="tocitem" href="#Resolving-pairs-of-trees"><span>Resolving pairs of trees</span></a></li><li><a class="tocitem" href="#Resolving-during-MCC-inference"><span>Resolving during MCC inference</span></a></li><li><a class="tocitem" href="#Resolving-with-inferred-MCCs"><span>Resolving with inferred MCCs</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">OptArgs</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Under the hood</a></li><li class="is-active"><a href>Resolving</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Resolving</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/TreeKnit.jl/blob/master/docs/src/resolving.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Resolving"><a class="docs-heading-anchor" href="#Resolving">Resolving</a><a id="Resolving-1"></a><a class="docs-heading-anchor-permalink" href="#Resolving" title="Permalink"></a></h1><p>The lack of resolution in the inference of phylogenetic trees results in <em>polytomies</em>: internal nodes with more than two offsprings.    Polytomies can cause the topology of two trees to differ, which cause problems when inferring reassortments using topological information.    Suppose for instance that we have a first tree (<em>e.g.</em> for a given segment of flu): </p><pre><code class="language-julia">t1 = node2tree(parse_newick(&quot;(A,(B,C))&quot;))</code></pre><pre class="documenter-example-output"> ----- NODE_1:missing
      |
      |
      ----- A:missing
      |
      |
      ----- NODE_2:missing
           |
           |
           ----- B:missing
           |
           |
           ----- C:missing
</pre><p>where we can identify the clade <code>(B,C)</code> because of a mutation in this segment present in <code>B</code> and <code>C</code> but not in <code>A</code>. </p><p>If this mutation does not exist in a second segment, then in the absence of reassortment its tree will look something like this: </p><pre><code class="language-julia">t2 = node2tree(parse_newick(&quot;(A,B,C)&quot;))</code></pre><pre class="documenter-example-output"> ----- NODE_1:missing
      |
      |
      ----- A:missing
      |
      |
      ----- B:missing
      |
      |
      ----- C:missing
</pre><p>As a result, <code>t1</code> and <code>t2</code> differ for a reason unrelated with reassortment. </p><p>To overcome this issue, one has to <strong>resolve</strong> trees as much as possible, typically using the information of one to remove polytomies in the other.    This can only be done if no reassortments are present. </p><h2 id="Resolving-pairs-of-trees"><a class="docs-heading-anchor" href="#Resolving-pairs-of-trees">Resolving pairs of trees</a><a id="Resolving-pairs-of-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Resolving-pairs-of-trees" title="Permalink"></a></h2><p>In the example above, it is natural to think that the difference between the two trees is due to a lack of resolution and not to reassortment.    This is because the split <code>(B,C)</code> in the first tree is <strong>compatible</strong> with the second tree: it is possible to add this split to <code>t2</code>.    What this means is that the difference in topology can be explained by something else than reassortment. </p><p>In this case, we can simply resolve <code>t2</code> by adding each split in <code>t1</code> with which it is compatible.    If <code>t1</code> has polytomies, the same could be done to resolve <code>t1</code> using <code>t2</code>.    This operation is performed by the <code>resolve!</code> function: </p><pre><code class="language-julia">new_splits = resolve!(t1, t2);
t2</code></pre><pre class="documenter-example-output"> ----- NODE_1:missing
      |
      |
      ----- A:missing
      |
      |
      ----- RESOLVED_1:0.0
           |
           |
           ----- B:missing
           |
           |
           ----- C:missing
</pre><p><code>resolve!</code> returns an array of <code>SplitList</code> objects (of the <em>TreeTools</em> package) containing the new splits introduced in each of the two trees: </p><pre><code class="language-julia-repl">julia&gt; isempty(new_splits[1])
true

julia&gt; new_splits[2]
[&quot;B&quot;, &quot;C&quot;]</code></pre><p>If the <code>resolve</code> option is passed to <code>computeMCCs</code> (through <code>OptArgs</code>), <code>resolve!</code> will be called on each pair of trees before each iteration of the MCC inference procedure. </p><h2 id="Resolving-during-MCC-inference"><a class="docs-heading-anchor" href="#Resolving-during-MCC-inference">Resolving during MCC inference</a><a id="Resolving-during-MCC-inference-1"></a><a class="docs-heading-anchor-permalink" href="#Resolving-during-MCC-inference" title="Permalink"></a></h2><p>The above resolving method works fine for simple &quot;obvious&quot; cases, where a split in one tree directly resolves a polytomy in another.  However, consider the following case: </p><pre><code class="language-julia">t1 = node2tree(parse_newick(&quot;((A,B),(C,(D,(E,X))))&quot;))
t2 = node2tree(parse_newick(&quot;((A,(B,X)),(C,D,E))&quot;))</code></pre><p>There are now two sources of topological differences between <code>t1</code> and <code>t2</code>: </p><ul><li>The reassorted strain <code>X</code>. </li><li>The lack of resolution resulted in a polytomy <code>(C,D,E)</code> in <code>t2</code>, which is resolved in <code>t1</code> in the form of <code>(C,(D,(E,X))</code> </li></ul><p>The <code>resolve!</code> function is helpless in such cases: </p><pre><code class="language-julia">new_splits = resolve!(t1, t2)
isempty(new_splits[2])</code></pre><pre class="documenter-example-output">true</pre><p>Indeed, there is no split in <code>t1</code> that can directly help us resolve <code>t2</code>.    The closest such split is <code>(D,E,X)</code>, but it is incompatible with <code>t2</code> because of <code>X</code>.    If we knew beforehand that <code>X</code> is reassorted, we could simply ignore it while resolving <code>t2</code>.    The <code>(D,E,X)</code> split in <code>t1</code> would become <code>(D,E)</code>, which is compatible with <code>t2</code>, and the <code>resolve!</code> function would handle this.  </p><p>However, the topology-based heuristic used by <em>TreeKnit</em> is not able to detect that <code>X</code> is the only reassorted leaf <em>if the trees are not resolved</em>!   Indeed, if we &quot;remove&quot; <code>X</code> from the trees, some incompatibilities will remain.    For instance, the split above <code>E</code> will be <code>(D,E)</code> in the first tree and <code>(C,D,E)</code> in the second.    Without resolving, the heuristic will predict a reassortment above almost every leaf: </p><pre><code class="language-julia">computeMCCs(t1, t2, OptArgs(;resolve=false))</code></pre><pre class="documenter-example-output">3-element Vector{Vector{String}}:
 [&quot;E&quot;]
 [&quot;X&quot;]
 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</pre><p>In order to achieve progress in this kind of situation, we have to perform two operations at the same time: </p><ul><li>realize that <code>X</code> is the only reassorted strain, and can be ignored when resolving.</li><li>resolve <code>t2</code> with the <code>(D,E,X)</code> split, ignoring <code>X</code>. </li></ul><p>This is done automatically during MCC inference if the <code>resolve</code> option of <code>OptArgs</code> is given (default):  </p><pre><code class="language-julia">MCCs = computeMCCs(t1, t2, OptArgs(;resolve=true))</code></pre><pre class="documenter-example-output">2-element Vector{Vector{String}}:
 [&quot;X&quot;]
 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]</pre><h2 id="Resolving-with-inferred-MCCs"><a class="docs-heading-anchor" href="#Resolving-with-inferred-MCCs">Resolving with inferred MCCs</a><a id="Resolving-with-inferred-MCCs-1"></a><a class="docs-heading-anchor-permalink" href="#Resolving-with-inferred-MCCs" title="Permalink"></a></h2><p>Once the MCCs are inferred, it is possible to use them to resolve trees: in the regions of shared branches of the ARG, the two trees <code>t1</code> and <code>t2</code> must have the same splits.    The <code>resolve!</code> function also has a method for this.    Using the example above, we have</p><pre><code class="language-julia-repl">julia&gt; resolved_splits = resolve!(t1, t2, MCCs)
2-element Vector{TreeTools.SplitList{String}}:

 [&quot;D&quot;, &quot;E&quot;]

julia&gt; t2
 ----- NODE_1:missing
      |
      |
      ----- NODE_2:missing
           |
           |
           ----- A:missing
           |
           |
           ----- NODE_3:missing
                |
                |
                ----- B:missing
                |
                |
                ----- X:missing
      |
      |
      ----- NODE_4:missing
           |
           |
           ----- C:missing
           |
           |
           ----- RESOLVED_1:0.0
                |
                |
                ----- D:missing
                |
                |
                ----- E:missing</code></pre><p>The split <code>(D,E)</code> is now present in <code>t2</code>.  Note that it was not present in <code>t1</code>: only the splits <code>(D,E,X)</code> and <code>(E,X)</code> existed there.  However, since <code>resolve!</code> now knows <code>(A,B,C,D,E)</code> is an MCC, the <code>resolve!</code> function can &quot;ignore&quot; leaf <code>X</code> when resolving.   </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../runopt/">« <code>runopt</code></a><a class="docs-footer-nextpage" href="../types/">OptArgs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Monday 17 January 2022 17:24">Monday 17 January 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
