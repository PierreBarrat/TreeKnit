var documenterSearchIndex = {"docs":
[{"location":"mccs/#MCCs","page":"MCCs","title":"Maximally Compatible Clades","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"TreeKnit reconstructs the ARG from trees by first inferring (topologically) shared regions of the tree, so called Maximally Compatible Clades (MCC). By default if they share the same topology up to resolution TreeKnit will assume the region is shared. ","category":"page"},{"location":"mccs/#Handling-trees","page":"MCCs","title":"Handling trees","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"Functions that directly handle trees are found in the separate TreeTools package, see its documentation.   Here are two useful ones: ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"read_tree(file): read tree from newick file, return Tree object. \nparse_newick_string(string): parse newick string into a Tree object. For convenience, this one is re-exported by TreeKnit. ","category":"page"},{"location":"mccs/#Simple-case","page":"MCCs","title":"Simple case","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"Let's see how to infer Maximally Compatible Clades (MCC) for a very simple case: two trees with five leaves. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"using TreeKnit\nt1 = parse_newick_string(\"((A,B),(C,(D,X)));\"; label=\"t1\")\nt2 = parse_newick_string(\"((A,(B,X)),(C,D));\"; label=\"t2\")","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"The run_treeknit! function takes two trees as input. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"mccs = run_treeknit!(t1, t2)","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"The output is an MCC_set object, which contains three fields:","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"no_trees: number of trees\norder_trees: Vector of tree labels, determines later order of calculations on tree pairs\nmccs: Dictionary of calculated mccs, the key is a set of labels of trees in each tree pair, the Individual MCCs are simply arrays containing labels of leaves of the trees. For example the array [\"X\"] corresponds to the MCC which contains the leaf \"X\".","category":"page"},{"location":"mccs/#Interpretation-of-results","page":"MCCs","title":"Interpretation of results","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"The genealogy of two RNA segments subject to reassortment is described by an Ancestral Reassortment Graph (ARG).  An ARG is a directed graph that represents the lineage of a given pair of segments by coalescence of nodes, as in a genealogical tree, but also shows reassortment events and the exchange of segments by nodes that have two ancestors.  Since reassortments only occur between segments, the genealogy of a given segment is described by a tree.  As a result, the ARG must embed both segment-trees, and every branch in the ARG has to belong to either one of the trees, or to both. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"TreeKnit infers the ARG by finding the branches that are common to both trees.  Given two trees with potentially different topologies, it tries to \"glue\" them together in a reasonable way, where the interpretation of reasonable can vary between parsimonious and conservative (see the parsimony parameter gamma). ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"The MCCs returned by run_treeknit! represent regions of the ARG (and of the segment trees) where branches are common to both trees.  In other words, these are the regions where the two segment trees must be \"glued together\".  Given those regions and the knowledge of the trees, it is possible to unambiguously reconstruct the genealogy. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"info: Number of reassortments in the genealogy\nWhen going up the ARG (backwards in time), a reassortment consists of passing from a region where branches are common to the two trees to a region where they are not. It is a split of branches.  As a consequence, the root of each MCC must be a reassortment, with the exception of an MCC containing the root of both trees.  The number of reassortments events in the inferred ARG can thus simply be obtained by counting the number of MCCs, potentially removing the one that contains the roots of both trees if it exists. ","category":"page"},{"location":"mccs/#naive_mccs","page":"MCCs","title":"Naive estimation","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"It is also possible to compute a \"naive\" estimation of MCCs using the naive keyword.    When naive is set to true, run_treeknit! returns maximum clades that are exactly compatible between pairs of trees: ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"using TreeKnit # hide\nt1 = parse_newick_string(\"(((A1,A2),(B1,B2)),(C1,C2));\"; label=\"t1\")\nt2 = parse_newick_string(\"(((A1,A2),(C1,C2)),(B1,B2));\"; label=\"t2\")\nrun_treeknit!(t1, t2; naive=true)","category":"page"},{"location":"visualization/#visualization","page":"Visualizing MCCs","title":"Visualizing MCCs","text":"","category":"section"},{"location":"visualization/#Visualizing-the-ARG","page":"Visualizing MCCs","title":"Visualizing the ARG","text":"","category":"section"},{"location":"visualization/","page":"Visualizing MCCs","title":"Visualizing MCCs","text":"IcyTree (Vaughan, T. G., IcyTree: Rapid browser-based visualization for phlogenetic trees and networks. Bioinformatics 2017. DOI: 10.1093/bioinformatics/btx155) is an in-browser application that can be used to view ARGs. Just drag and drop the extended newick file obtained from TreeKnit and see the results. ","category":"page"},{"location":"visualization/","page":"Visualizing MCCs","title":"Visualizing MCCs","text":"A TreeKnit visualization app is also under development. It should visualize ARGs in a similar manner to IcyTree, but with colored tree segment annotations. The prototype can be used to visualize ARG results. ","category":"page"},{"location":"visualization/#view_auspice","page":"Visualizing MCCs","title":"Visualizing MCCs using a tanglegram in Auspice","text":"","category":"section"},{"location":"visualization/","page":"Visualizing MCCs","title":"Visualizing MCCs","text":"Tanglegrams are an excellent way to view reassortment events between trees. In a tanglegram two trees are joint at the leaves and viewed facing each other. Auspice is an excellent option for visualizing tanglegrams of large trees as it can uniquely color different MCCs allowing for easy comparison of tree topologies. Viewing tanglegrams in Auspice with MCC colorings requires specific files, which will be generated when TreeKnit is run with the --auspice-view argument. ","category":"page"},{"location":"visualization/","page":"Visualizing MCCs","title":"Visualizing MCCs","text":"In julia these files can be produced using the command: TreeKnit.write_auspice_json(filepath::String, tree1::Tree{T}, tree2::Tree{T}, MCCs::Vector{Vector{String}}). ","category":"page"},{"location":"visualization/","page":"Visualizing MCCs","title":"Visualizing MCCs","text":"This command will return JSON files with the naming convention: \"auspice_{tree.label}.json\" for each tree. Each tree can viewed separately by dragging and dropping the corresponding file into https://auspice.us/. Two trees can be viewed as together as a tanglegram by selecting them together and dragging and dropping them into the auspice browser. The trees can then be colored with the desired MCCs, these can be chosen by selecting them from the color by menu at the left hand side of the browser. MCCs are labeled as mcc_x_y, where x and y are the labels of tree1 and tree2 in alphabetical order.","category":"page"},{"location":"visualization/","page":"Visualizing MCCs","title":"Visualizing MCCs","text":"The resulting tanglegram for the NY data set should look as follows:","category":"page"},{"location":"visualization/","page":"Visualizing MCCs","title":"Visualizing MCCs","text":"(Image: plot) ","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"CurrentModule = TreeKnit\nDocTestSetup  = quote\n    using TreeTools\nend\t","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"functions/#Function-used-for-the-CLI","page":"Functions","title":"Function used for the CLI","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"TreeKnit.treeknit","category":"page"},{"location":"functions/#TreeKnit.treeknit","page":"Functions","title":"TreeKnit.treeknit","text":"treeknit\n\nWe suggest two methods for running TreeKnit:\n\n--better-trees: this method is recommended for users using more than 2 trees. It will:\nresolve all trees compatibly before inferring MCCs;\nrun 1 round of treeknit on all tree pairs independently, not resolving in the process;\n\nThis technique was found to produce better resolved trees. The MCCs are less accurate, but more homogeneous: if nodes are inferred to be in the same MCC, it is likely to be true. However, it will likely predict more reassortments (and MCCs) than needed.\n\n--better-MCCs: this method is recommended for users using 2 trees, or users who are more interested in inferring accurate MCCs. It will:\nresolve all trees compatibly before inferring MCCs;\nrun 1 round of treeknit inference on all tree pairs sequentially, further resolving trees in the process (note that order in which tree pairs are processed matters);\nrun a second round of treeknit on all tree pairs, without resolving.\n\nThis technique was found to produce the most accurate MCCs, but the output trees will potentially have a higher amount of inaccurate splits.\n\nArguments\n\nnwk_files: Newick files (requires 2 or more trees - note an ARG currently cannot be created for more than 2 trees)\n\nOptions\n\n-o, --outdir <arg>: directory for results; Example -o=treeknit_results\n-g, --gamma <arg>: value of γ; Example -g=2\n--seq-lengths <arg>: length of the sequences. Example: --seq-length \"1500 2000\"\n--n-mcmc-it <arg>: number of MCMC iterations per leaf; default 25\n--rounds <arg>: Number of times to run inference on input trees. If rounds > 1 MCCs will be re-inferred using resolved trees from the last iteration. (default: 1)\n--verbosity-level <arg>: set value of verbosity. Default 0. -v flag sets it to 1. Set to 2 for maximum verbosity (only useful for small trees). Set to -1 for no output at all\n\nFlags\n\n--better-trees: Use the --better-trees method (default for >2 trees)\n--better-MCCs: Use the --better-MCCs method (default for 2 trees)\n--naive: Naive inference (overrides -g).\n--no-resolve: Do not attempt to resolve trees before inferring pairwise MCCs.\n--liberal-resolve: Resolve output trees as much as possible using inferred MCCs, adding splits when order of coalescence and reassortment is unclear (coalescence is set at a time prior to reassortment)\n--resolve-all-rounds: Resolve trees before inferring pairwise MCCs in all rounds, overrides --no-resolve (default for 2 trees, for more than 2 trees default is to not resolve in the final round)\n--no-pre-resolve: Do not compatibly resolve all trees with each other before inferring MCCs (default is to pre-resolve)\n--no-likelihood: Do not use branch length likelihood test to sort between different MCCs\n--parallel: Run sequential TreeKnit with parallelization (only used for 3 or more trees)\n-v, --verbose: set verbosity to 1\n--auspice-view: return ouput files for auspice\n\n\n\n\n\n","category":"function"},{"location":"functions/#Computing-Maximal-Compatible-Clades-(MCCs)-for-pairs","page":"Functions","title":"Computing Maximal Compatible Clades (MCCs) for pairs","text":"","category":"section"},{"location":"functions/#Main-functions","page":"Functions","title":"Main functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"run_treeknit!","category":"page"},{"location":"functions/#TreeKnit.run_treeknit!","page":"Functions","title":"TreeKnit.run_treeknit!","text":"run_treeknit!(trees, oa::OptArgs; naive=false) where T\nrun_treeknit!(trees; kwargs...)\n\nMain TreeKnit run function. \n\nComputes MCCs of all tree pairs in tree list trees. In the second form, the keyword arguments are passed to OptArgs.\n\nParameters:\n\npre_resolve=true: input trees are resolved with each other prior to MCC computation.\nresolve=true: input trees are resolved in each pair-wise MCC computation, resolved trees are used as   input trees for the next pair, the order is specified in Combinatorics.combinations(1:length(trees), 2). \nnaive: return naive MCCs of all tree pairs.\nstrict: Apply conservative resolution. If an MCC implies a coalescence event occured, but the order of reassortment and  coalescence is ambiguous, more than one split could be added to the tree. In such an event strict resolve does not add a  split, however liberal = (strict==false) resolution would choose one such order of events and add that respective split. \nparallel: Parallelize MCC computation of tree pairs as much as possible.\n\n\n\n\n\n","category":"function"},{"location":"functions/#For-pairs-of-trees-only","page":"Functions","title":"For pairs of trees only","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"naive_mccs\nTreeKnit.runopt","category":"page"},{"location":"functions/#TreeKnit.naive_mccs","page":"Functions","title":"TreeKnit.naive_mccs","text":"naive_mccs(treelist)\n\nFind sets of nodes which are:\n\nclades in all trees of treelist,\nall subclades of nodes are clades in all trees of treelist (both of these properties define consistency),\nmaximal: adding a node to a set results it in not being a clade in at least one of the trees.\n\nAll the trees of treelist should share the same leaf nodes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#TreeKnit.runopt","page":"Functions","title":"TreeKnit.runopt","text":"\trunopt(t1::Tree, t2::Tree; kwargs...)\n\trunopt(oa::OptArgs, t1::Tree, t2::Tree)\n\nRun optimization at constant γ. See ?Optargs for arguments. In the first form, keyword arguments are given to OptArgs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Resolving-trees","page":"Functions","title":"Resolving trees","text":"","category":"section"},{"location":"functions/#Using-topology","page":"Functions","title":"Using topology","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"resolve!(::TreeTools.Tree, ::TreeTools.Tree)","category":"page"},{"location":"functions/#TreeKnit.resolve!-Tuple{TreeTools.Tree, TreeTools.Tree}","page":"Functions","title":"TreeKnit.resolve!","text":"resolve!(t1::Tree, t2::Tree, tn::Vararg{Tree}; tau=0.)\n\nResolve t1 using splits of t2 and inversely. Every split of t2 a tree that is compatible with t1 is introduced in t1 with branch length tau (and inversely).  Return new splits in each tree.\n\nIf more than two trees are given, only introduce a split from ti in tree tj if  the split is compatible with all trees.\n\nresolve!(t1::Tree{T}, t2::Tree{T}, MCCs; tau = 0., strict=true)\n\nResolve t1 using t2 and t2 using t1, both using the list of MCCs. Return the list of resolved splits in each tree.\n\nMCCs: Vector{Vector{String}}. List of MCCs. Each MCC is a vector of leaf names.\ntau: New branches have a length tau. \nstrict: if strict or liberal resolution should be used.   If strict, only introduce unambiguous splits.\n\n\n\n\n\n","category":"method"},{"location":"runopt/#The-runopt-function","page":"runopt","title":"The runopt function","text":"","category":"section"},{"location":"runopt/","page":"runopt","title":"runopt","text":"using TreeKnit\nusing TreeKnit.SplitGraph\nusing TreeTools","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"For larger trees, opttrees will not find all reassortments at once.    The reason for this is that it is often necessary to \"clean\" reassorted leaves in smaller clades in order to see other reassortments deeper in the tree.    As a consequence, trees obtained after one round of opttrees will still have incompatibilities.  Below is a relatively simple example of trees for which opttrees does not find all reassorted leaves in one go: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"nwk1 = \"(Z,(G,(((A,X),(B,C)),((D,Y),(E,F)))));\"\nnwk2 = \"(G,((A,(B,(C,X))),((D,(E,(F,Y))),Z)));\"\nt1 = parse_newick_string(nwk1; label=\"t1\")\nt2 = parse_newick_string(nwk2; label=\"t2\")\nnothing # hide","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"These trees are constructed in the following way (you're encouraged to draw them!): ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Clade ((A,X),(B,C)) in the first tree \"corresponds\" to clade (A,(B,(C,X))) in the second tree, with X as the reassorted leaf.  Same goes for clades ((D,Y),(E,F)) and (D,(E,(F,Y))) and the reassorted leaf Y. \nWe respectively name these not yet compatible clades ABC and DEF. At a deeper level, the trees are now of the form (Z,(G,(ABC,DEF))) for the first and (G,(ABC,(DEF,Z))) for the second, with Z as the obvious reassorted leaf. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"The important property here is that for a high enough value of gamma, it is only possible for opttrees to see that Z is reassorted if clades ABC and DEF are \"coarse-grained\" to leaves.    In return, this coarse-graining is only possible after X and Y have been identified as reassorted leaves, which will happen after a first iteration of opttrees.     The task of iterating opttrees is performed by the runopt function.    Here, we walk through the typical steps it takes.","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Let's do a first pass with opttrees, with gamma=3.     We first build the SplitGraph object, as detailed in the opttrees page. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"treelist = Any[t1, t2]\nmccs_naive = naive_mccs(treelist) # these are just the leaves in this example\nmcc_names = TreeKnit.name_mcc_clades!(treelist, mccs_naive)\nfor (i,t) in enumerate(treelist)\n  treelist[i] = TreeKnit.reduce_to_mcc(t, mccs_naive)\nend\ng = SplitGraph.trees2graph(treelist);\nnothing # hide","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"We then run the simulated annealing optimization to find optimal leaves to remove. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"opt_confs = SplitGraph.sa_opt(g; Trange = reverse(1e-3:1e-2:1), M = 10, γ = 3)[1]\nmccs_found = [mcc_names[x] for x in g.labels[.!opt_confs[1]]]","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"info: On setting $\\gamma$\nHere gamma = 2, if you run this example using gamma leq 2, Z will immediatly be found as a reassorted strain.  It is indeed not easy to find an example of a case with trees with a small number of leaves (9 here), obvious reassortments, and that are not solved in one go by opttrees with a low value of gamma.  However, when dealing with trees with hundreds of leaves, finding all MCCs in one go is the exception rather than the rule. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"As expected, X Y are found as reassortments.    However, the two trees will still have incompatibilities when removing those two leaves.    To make this explicit, we remove the leaves X and Y and compute naive mccs again. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"TreeKnit.pruneconf!(mccs_found, treelist...) # prune clades in a list of trees. Wrapper around TreeTools.prunesutree!\nmccs_naive = naive_mccs(treelist...)","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Now that X and Y are removed, we see that clades ABC and DEF are common to both trees.    If we reduce the pruned trees to their new naive MCCs again, we now see that Z is an obvious choice for a reassorted strain: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"mcc_names = TreeKnit.name_mcc_clades!(treelist, mccs_naive)\nfor (i,t) in enumerate(treelist)\n  treelist[i] = TreeKnit.reduce_to_mcc(t, mccs_naive)\nend\ntreelist[1]\ntreelist[2]","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"To finish the inference of MCCs, we would now have to re-run the optimization process, i.e. opttrees has to be iterated. This is performed automatically by the runopt function. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"This process stops when one of the following end conditions is fulfilled: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"If no new MCCs are found in a given iteration of opttrees stop.\nIf new MCCs were found, prune them from the trees.  If the resulting trees do not have any incompatibilities stop.\nIf the maximum number of iterations has been reached stop. This number can be set through OptArgs, the default is 15. ","category":"page"},{"location":"resolving/#resolving","page":"Resolving","title":"Resolving","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The lack of resolution in the inference of phylogenetic trees results in polytomies: internal nodes with more than two offsprings.    Polytomies can cause the topology of two trees to differ, which cause problems when inferring reassortments using topological information.    Suppose for instance that we have a first tree (e.g. for a given segment of flu): ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using TreeKnit # hide\nt1 = parse_newick_string(\"(A,(B,C));\")","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"where we can identify the clade (B,C) because of a mutation in this segment present in B and C but not in A. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"If this mutation does not exist in a second segment, then in the absence of reassortment its tree will look something like this: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t2 = parse_newick_string(\"(A,B,C);\")","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"As a result, t1 and t2 differ for a reason unrelated with reassortment. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"To overcome this issue, one has to resolve trees as much as possible, typically using the information of one to remove polytomies in the other.    This can only be done if no reassortments are present. ","category":"page"},{"location":"resolving/#Resolving-trees","page":"Resolving","title":"Resolving trees","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In the example above, it is natural to think that the difference between the two trees is due to a lack of resolution and not to reassortment.    This is because the split (B,C) in the first tree is compatible with the second tree: it is possible to add this split to t2.    What this means is that the difference in topology can be explained by something other than reassortment. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In this case, we can simply resolve t2 by adding each split in t1 to t2 with which t2 is compatible.    If t1 has polytomies, the same could be done to resolve t1 using t2.    This operation is performed by the resolve! function: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using TreeKnit\nt1 = parse_newick_string(\"(A,(B,C));\")\nt2 = parse_newick_string(\"(A,B,C);\")","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"new_splits = resolve!(t1, t2);\nt2","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"resolve! returns an array of SplitList objects (of the TreeTools package) containing the new splits introduced in each of the two trees: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"isempty(new_splits[1])\nnew_splits[2]","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The resolve! function can also be called on more than three trees. When called on more than 2 trees it will only introduce splits from one tree into another tree if that split is compatible with all other trees. Take the same 2 trees from before (t1 and t2) and assume we add a third tree t3","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using TreeKnit\nt1 = parse_newick_string(\"(A,(B,C));\")\nt2 = parse_newick_string(\"(A,B,C);\")","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t3 = parse_newick_string(\"(A,B,C);\")\nnew_splits = resolve!(t1, t2, t3);\nt2\nt3","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"As the (B,C) split is compatible with both the 2nd and the 3rd tree it will be introduced in both trees. Now assume we add a 4th tree where the (B,C) split is no longer compatible. Now neither tree t2 or t3 will be further resolved.","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using TreeKnit\nt1 = parse_newick_string(\"(A,(B,C));\")\nt2 = parse_newick_string(\"(A,B,C);\")\nt3 = parse_newick_string(\"(A,B,C);\")\nt4 = parse_newick_string(\"((A,B),C);\")","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"new_splits = resolve!(t1, t2, t3, t4);\nt2\nt3","category":"page"},{"location":"resolving/#Resolving-during-MCC-inference-for-tree-pairs","page":"Resolving","title":"Resolving during MCC inference for tree pairs","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The above resolving method works fine for simple \"obvious\" cases, where a split in one tree directly resolves a polytomy in another.  However, consider the following case: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using TreeKnit","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t1 = parse_newick_string(\"((A,B),(C,(D,(E,X))));\"; label=\"t1\")\nt2 = parse_newick_string(\"((A,(B,X)),(C,D,E));\"; label=\"t2\")","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"There are now two sources of topological differences between t1 and t2: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The reassorted strain X. \nThe lack of resolution resulted in a polytomy (C,D,E) in t2, which is resolved in t1 in the form of (C,(D,(E,X)) ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The resolve! function is helpless in such cases: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"new_splits = resolve!(t1, t2)\nisempty(new_splits[2])","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Indeed, there is no split in t1 that can directly help us resolve t2.    The closest such split is (D,E,X), but it is incompatible with t2 because of X.    If we knew beforehand that X is reassorted, we could simply ignore it while resolving t2.    The (D,E,X) split in t1 would become (D,E), which is compatible with t2, and the resolve! function would handle this.  ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"However, the topology-based heuristic used by TreeKnit is not able to detect that X is the only reassorted leaf if the trees are not resolved!   Indeed, if we \"remove\" X from the trees, some incompatibilities will remain.    For instance, the split above E will be (D,E) in the first tree and (C,D,E) in the second.    Without resolving, the heuristic will predict a reassortment above almost every leaf: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"run_treeknit!(t1, t2, OptArgs(;resolve=false))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In order to achieve progress in this kind of situation, we have to perform two operations at the same time: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"realize that X is the only reassorted strain, and can be ignored when resolving.\nresolve t2 with the (D,E,X) split, ignoring X. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"This is done automatically during MCC inference if the resolve option of OptArgs is given (default):  ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"MCCs = run_treeknit!(t1, t2, OptArgs(;resolve=true))","category":"page"},{"location":"resolving/#Resolving-with-inferred-MCCs-for-tree-pairs","page":"Resolving","title":"Resolving with inferred MCCs for tree pairs","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Once the MCCs are inferred, it is possible to use them to resolve trees: in the regions of shared branches of the ARG, the two trees t1 and t2 must have the same splits.    The resolve! function also has a method for this.    Using the example above, we have","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t1 = parse_newick_string(\"((A,B),(C,(D,(E,X))));\"; label=\"t1\");\nt2 = parse_newick_string(\"((A,(B,X)),(C,D,E));\"; label=\"t2\");\nresolved_splits = resolve!(t1, t2, MCCs.mccs[Set([\"t1\", \"t2\"])]; strict=true)\nt2","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The split (D,E) is now present in t2.  Note that it was not present in t1: only the splits (D,E,X) and (E,X) existed there.  However, since resolve! now knows (A,B,C,D,E) is an MCC, the resolve! function can \"ignore\" leaf X when resolving.   ","category":"page"},{"location":"resolving/#resolve_strict_vs_liberal","page":"Resolving","title":"Strict vs liberal resolve","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"When resolving using MCCs, TreeKnit uses one of two options: strict (default) or liberal resolution (--liberal-resolve flag).  Given two trees t1 and t2 and their MCCs, it is not always possible to unambiguously resolve t2 using the splits of t1 even in an MCC.  To explain this, we consider the two following trees: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using TreeKnit # hide\nusing TreeTools # hide\nt1 = parse_newick_string(\"((A,(B,C)),D);\")\nt2 = parse_newick_string(\"(A,B,C,D);\")","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Assume that the MCCs are [A,B,C] and [D]. In this minimal example this is a bit contrived, but this type of situation can take place in larger  trees.  The essential ingredients here are ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"the polytomy (A,B,C,D) in t2. \nthe fact that the (A,(B,C)) clade is nicely resolved in t1\n(A,B,C), D, and the other nodes being in different MCCs, meaning there is a reassortment above leaf D and above the MRCA of (A,B,C)","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"At first sight, we would like to introduce the splits (A,B,C) and (B,C) into t2: these splits exist in t1 and are in the shared region (A,B,C).  This would result in the following for t2: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t2_resolved_1 = parse_newick_string(\"((A,(B,C)),D);\")","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"However, since there is a reassortment above D, we cannot exclude D being nested in the (A,B,C) clade  This gives us other possibilities for t2 (non-exhaustive):","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t2_resolved_2 = parse_newick_string(\"(A,(B,(C,D)));\")\nt2_resolved_3 = parse_newick_string(\"(A,((B,C),D));\")","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"All the above possibilities to resolve t2 are compatible with the found MCCs and the splits in t1. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The strict and liberal options for resolution make different choices in this situation. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Strict resolve will consider this situation as ambiguous, and not attempt any resolution. Hence the final t2 will have a Newick string \"(A,B,C,D);\".  More generally, with the strict option, TreeKnit will only resolve a polytomy if the relation of all branches within the polytomy can be unambiguously determined using the other tree, potentially not fully resolving shared regions of the trees. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"MCCs = [[\"D\"], [\"A\", \"B\", \"C\"]]\nnew_splits_strict = resolve!(t1, t2, MCCs; strict=true);\nisempty(new_splits_strict[2])\nt2","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Liberal resolve will resolve trees as much as possible, fully resolving shared regions of the two trees, but arbitrarily choosing the location of these aforementioned branches, leading to potentially wrong splits.  As in the example below, liberal resolve will always try to \"pull\" MCCs out of polytomies ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t1 = parse_newick_string(\"((A,(B,C)),D);\") # hide\nt2 = parse_newick_string(\"(A,B,C,D);\") # hide\nnew_splits_liberal = resolve!(t1, t2, MCCs; strict=false);\nnew_splits_liberal[2]\nt2","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Here are a few extra notes on strict vs liberal options: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"liberal resolve will in general result in significantly more wrong splits placed in the trees\nto create an ARG, it is necessary that MCCs are resolved exactly the same in both trees: the trees must be knitted together in those regions.  For this reason, it is also necessary to use liberal resolve for ARG reconstruction. ","category":"page"},{"location":"multitreeknit/#multitreeknit","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"","category":"section"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"TreeKnit can be used to infer reassortment events between multiple tree pairs. When reassortment events between three or more trees should be inferred, TreeKnit uses a recursive inference strategy to:","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"resolve each tree using information from all other trees in a consistent manner,\nidentify shared regions of each tree pair (MCCs),\nfind reassortment events between tree pairs.","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"The following example illustrates the benefits of this inference strategy over running TreeKnit individually on all tree pairs. Note however, that MultiTreeKnit may still return MCCs that are inconsistent with each other, which prevents the construction of an ARG. Therefore, we do not reconstruct an ARG for more than two trees. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"In the overview section, we described two versions of TreeKnit, differing by the number of inference rounds. The first version, the :better_trees method is the default method for K2 trees. It has been optimized for using multiple reassorting segments to infer parameters of pathogen evolution. We optimized for sensitivity in MCC inference and polytomy resolution, minimizing the false positive rate for shared branches and new splits, but increasing the false negative rate, i.e. typically inferring too many reassortment events. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"In the following section we shall explain the differences between the two methods, using a three tree example.  ","category":"page"},{"location":"multitreeknit/#MultiTreeKnit-Example","page":"MultiTreeKnit","title":"MultiTreeKnit Example","text":"","category":"section"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"(Image: plot)","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"The figure shows an ARG, of three tree segments, marked by their respective colors. The real MCCs of the trees are visible on the lower right. Mutations on the tree segments are marked with diamonds, the 2. segment has less mutations and is thus not fully resolved. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"You can follow along in the repl with the commands:","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"using TreeKnit, TreeTools\nt1 = parse_newick_string(\"((A,(B,C)),(D,E));\"; label=\"t1\");\nt2 = parse_newick_string(\"((A,B,C,D),E);\"; label=\"t2\");\nt3 = parse_newick_string(\"((A,B),((C,D),E));\"; label=\"t3\");","category":"page"},{"location":"multitreeknit/#The-better-trees-method","page":"MultiTreeKnit","title":"The --better-trees method","text":"","category":"section"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"All trees are compatibly pre-resolved with each other (this can be deactivated with the --no-pre-resolve flag). In this case no additional splits can be added. For example, we try to add the (B C) and the (A B C) into tree_2 but as the two splits are not compatible with tree_3 they will not be introduced.\nRun 1 round of standard TreeKnit without resolution on all tree pairs. As trees are not further resolved this can be fully parallelized. Note that MCC_12 and MCC_23 will not be properly inferred without resolution. Potential inferred MCC_12 are:","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"MCC_12 = A D B C D E","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"MCC_12 = B D A C D E","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"MCC_12 = C D A B D E","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"Ladderize the first tree and sort all polytomies according to to this tree to allow for visualization as a tanglegram. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"In this example the trees will not be further resolved, leading to no inaccurate splits being introduced.","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"This is called in the repl via the command:","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"MCCs = run_treeknit!([t1, t2, t3], OptArgs(3;method=:better_trees));","category":"page"},{"location":"multitreeknit/#The-better-MCCs-method","page":"MultiTreeKnit","title":"The --better-MCCs method","text":"","category":"section"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"All trees are compatibly pre-resolved with each other (this can be deactivated with the --no-pre-resolve flag). As before no additional splits can be added.\nRun 1 round of standard TreeKnit with strict resolution on all tree pairs. As trees are further resolved this must be done in a specific ordering and can only be partially parallelized (see consistent resolution). As we choose the input order of trees as the order to compute MCCs and resolve trees in we first compute MCC_12, then MCC_13 and lastly MCC_2 3. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"If the SA converges we will infer the correct MCC for MCC_12. Note the (B C) and the (A B C) split will not be added as we are using strict resolution and the order of the reassortment and the recombination event cannot be determined from trees. I.e. as D is in a different location in tree_1 its location in tree_2 cannot be inferred from tree_1, and the splits (B C D) and (A B C D) as well as the splits (B C), (B C D) and (A B C D) are also possible. This is what we refer to as an ambiguous split. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"t1 = parse_newick_string(\"((A,(B,C)),(D,E));\"; label=\"t1\");\nt2 = parse_newick_string(\"((A,B,C,D),E);\"; label=\"t2\");\nt3 = parse_newick_string(\"((A,B),((C,D),E));\"; label=\"t3\");\nrS = resolve!(t1, t2, [[\"D\"],[\"A\", \"B\", \"C\", \"E\"]])\nisempty(rS[2])","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"If the SA converges we shall infer the correct MCC_13\nWe then compute MCC_23, if the SA converges we will infer MCC_23 = E A B C D","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"there is only one way to resolve tree_2 to have such an MCC with tree_3 and we will introduce the splits (A B) and (C D) in tree_2. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"rS = resolve!(t2, t3, [[\"E\"], [\"A\", \"B\", \"C\", \"D\"]])\nisempty(rS[1])","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"Run a second round of pair-wise TreeKnit without resolution, this is required to make sure that all output MCCs are actually MCCs. Note for example that MCC_13 is no longer an MCC now that tree_2 has been further resolved. Not only are the MCCs less accurate in this example, we have added incorrect splits to tree_2. (Note that if tree_2 still had the (A B C) split this approach would have potentially correctly resolved trees and inferred the correct MCCs, however on average the first approach outperforms this approach). A potential MCC output for this example would be:","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"MCC_12 = C D A B E","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"MCC_13 = C A B D E","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"MCC_23 = E A B C D E","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"Ladderize the first tree and sort all polytomies according to to this tree to allow for visualization as a tanglegram.","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"This is called in the repl via the command:","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"MCCs = run_treeknit!([t1, t2, t3], OptArgs(3;method=:better_MCCs));","category":"page"},{"location":"multitreeknit/#consistent_resolution","page":"MultiTreeKnit","title":"Consistent resolution","text":"","category":"section"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"(Image: plot)","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"When TreeKnit is run individually on all tree pairs trees could be resolved inconsistently. By default TreeKnit resolves trees when searching for reassortment events, this is especially important for influenza where resolution is often low and not resolving trees can lead to much higher rates of reassortment being inferred. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"We explore the small example, seen above. First let us look at what would happen if standard pair-wise TreeKnit was run on all tree pairs with resolution. When the MCCs of tree a and tree c are computed no reassortment events would be found as tree c would be resolved according to tree a (i.e. a branch would be introduced above leaves A and B). However, when the MCCs of tree b and tree c are computed tree c would be resolved according to tree b and a branch would be introduced above leaves B and C. These two different resolutions of tree c are incompatible with each other and do not allow us to use this reassortment event information together.","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"In our default version of TreeKnit, the so called :better_trees method, we would first try to pre-resolve all trees using each other. In this case, as the (A B) and the (B C) split are not compatible, we do not know which to introduce into tree c and thus we would not introduce any new splits. We would then compute all MCC-pairs without resolution, which would mean inferring reassortment events between all trees. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"The other approach would be to choose to resolve tree c with tree a OR with tree b, inferring less reassortment events, which is more likely to be true. However, we have no information which tree we should use to resolve tree c.If we use the :better_MCCs method of TreeKnit, TreeKnit will perform 2 rounds of inference, resolving trees using tree order in the first round of inference. The order that pairs are resolved in is shown in the picture below ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"(Image: plot)","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"Here T_12 corresponds running pair-wise TreeKnit with the resolve=true flag and outputting the resolved tree 1 and tree 2. These resolved trees are then used to calculate the MCCs of the next neighboring tree pairs (which are connected by arrows). This means that after calculating the MCCs for tree 1 and tree 2 and resolving their polytomies using each other, instead of using the original tree 1 the resolved tree 1 is then further used when calculating the MCCs between tree 1 and tree 3. Leading to a consistent tree resolution.","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"Furthermore, we use strict resolution when resolving trees with MultiTreeKnit. Strict resolve will only resolve polytomies if the location of each branch in the new split can be fully determined by the other tree. Using strict resolve prevents the introduction of incorrect splits into the trees, this is especially important when resolved trees are used downstream for inference as these splits could prevent the simulated annealing from converging. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"At the end of the sequential inference on all tree pairs, each tree will be resolved as much as possible using each other tree. However, the output MCCs might not be consistent with each other and might not fulfill the necessary transitivity requirements to create an ARG (see consistent MCCs). ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"Furthermore, it can occur that the MCCs inferred for the tree pairs that were calculated at the start of the round are no longer MCCs (see the example above). We prevent this from happening, and make sure that all MCCs that are inferred are actual MCCs by running a final round where we re-infer all tree pair MCCs without resolving trees. However, the MCCs might still not fulfill all necessary consistency conditions to produce an ARG.","category":"page"},{"location":"multitreeknit/#consistent_MCCs","page":"MultiTreeKnit","title":"Consistent MCCs","text":"","category":"section"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"(Image: plot)","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"When TreeKnit is run individually on all tree pairs the final MCCs might be inconsistent with each other.  This was seen in the example above when TreeKnit is run on these tree pairs individually not only are the trees resolved in an incompatible manner the transitivity of the MCCs is also broken. Let us further explore this example. If no reassortment has occurred between leaves A and B in tree a and tree c and no reassortment has occurred between these leaves in tree b and tree c, reassortment cannot have occurred between A and B in tree a and tree b. However, there has clearly been a reassortment event between trees tree a and tree b. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"However, fixing resolution issues as described above does not necessarily fix transitivity. TreeKnit uses simulated annealing and removes branches at random. This means that even if tree c is now resolved according to tree a and we infer that a reassortment event has happened between trees tree a and tree b as well as between trees tree c and tree b the MCCs that TreeKnit infers might be inconsistent with each other. For example look at the following MCCs:","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"{ \n    \"MCC_dict\" : {\n        \"1\": { \n            \"trees\":[\"a\", \"b\"],\n            \"mccs\": [[\"A\"],[\"B\",\"C\"]]\n            },\n        \"2\": { \n            \"trees\":[\"a\", \"c\"],\n            \"mccs\": [[\"A\",\"B\",\"C\"]]\n            },\n        \"3\": { \n            \"trees\":[\"b\", \"c\"],\n            \"mccs\": [[\"A\",\"B\"],[\"C\"]]\n        }\n    }\n}","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"These MCCs show that no reassortment has occurred between leaves B and C in tree a and tree b and no reassortment has occurred between these leaves in tree_a and tree_c. Thus, for transitivity to hold reassortment cannot have occurred between B and C in tree b and tree c. But this is not the case. Such inconsistencies make it impossible to visualize an ARG. Currently, we are not able to fully fix such incompatibilities. ","category":"page"},{"location":"multitreeknit/#Parallel-MultiTreeKnit","page":"MultiTreeKnit","title":"Parallel MultiTreeKnit","text":"","category":"section"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"For 3 or more trees the --parallel flag can be used to run TreeKnit in parallel. When the :better_trees method is used and MCCs are inferred for tree pairs without further resolving trees, we can fully parallelize all calls of standard pair-wise TreeKnit on all fracK(K-1)2 tree pairs (where K is the number of trees). However, when the :better_MCCs method is applied and trees are additionally resolved in the first round of pair-wise TreeKnit, an ordering of jobs is required. This ordering can be easily determined from the recursive order graph. By running trees in parallel we can improve run time from order K^2 to K, where K is the number of trees.","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"(Image: plot) ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"For example, in order to compute the MCCs of tree 1 and tree 4 or T_14 we must have calculated T_12 and T_13. In order to compute the MCCs of tree 2 and tree 3 we also need T_12 and T_13 but we do not need to know T_14. Thus, T_14 and T_23 can be calculated at the same time, T_24 must wait for T_14 and T_23 to finish, and T_34 must in turn wait for T_24. Thus, the arrows in the recursive order graph also determine the work flow in parallel computing. As can be seen the longest path is from T_12 to T_14 and then down to T_34, and is of length 2K - 2, whereas there are a total of fracK(K-1)2 pairs which would mean a quadratic runtime without parallelization. ","category":"page"},{"location":"multitreeknit/","page":"MultiTreeKnit","title":"MultiTreeKnit","text":"Per default the --parallel flag is set to false to avoid potential platform issues. When using TreeKnit on a larger computing cluster it is best practice to set the desired number of cluster nodes to 1, and cpu number on that node as high as desired. ","category":"page"},{"location":"opttrees/#opttrees","page":"opttrees","title":"The opttrees function","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The core of the heuristic TreeKnit is based on happens in the opttrees function, found in the SplitGraph submodule.    Given two trees, opttrees attempts to reconcile them by pruning certain clades.    A quick description of different steps in this function is given here, with the two simple trees below as an example case: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"using TreeKnit# hide\nnwk1 = \"(((A1:1,A2:2):2,(B1:2,(B2:1,B3:1):1):2):2,(C1:1,C2:2):4);\";\nnwk2 = \"((A1:1,A2:2):2,((B1:2,(B2:1,B3:1):1):1,(C1:1,C2:2):1):1);\";\nt1 = parse_newick_string(nwk1; label=\"t1\")\nt2 = parse_newick_string(nwk2; label=\"t2\")\nnothing # hide","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trees are not displayed here for space reasons, but you're encouraged to draw them if you want to follow along! ","category":"page"},{"location":"opttrees/#Coarse-graining-of-naive-MCCs","page":"opttrees","title":"Coarse-graining of naive MCCs","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"As a first step, naive MCCs are computed for input trees using the naive_mccs function.    Here, we find three clades that are already compatible between the two trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"treelist = Any[t1, t2]\nmcc = naive_mccs(treelist)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trees are then \"reduced\" to those MCCs: new trees are built where each leaf corresponds to one of the naive MCCs.    The reduced trees have incompatibilities at the leaf level: it is no longer possible to group some of their leaves together in a consistent clade.  ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"mcc_names = TreeKnit.name_mcc_clades!(treelist, mcc)\nfor (i,t) in enumerate(treelist)\n\ttreelist[i] = TreeKnit.reduce_to_mcc(t, mcc)\nend\nnothing # hide","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The trees in treelist are now a reduced form of t1 and t2, and the names of the new leaves correspond to clades in the original tree.    The mapping between leaf name and original clade is stored in mcc_names","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"treelist[1]\ntreelist[2]\nmcc_names","category":"page"},{"location":"opttrees/#The-SplitGraph-object","page":"opttrees","title":"The SplitGraph object","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Once the two trees are reduced to their naive MCCs, we construct a SplitGraph object from them. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"info: *SplitGraph* submodule\nThe SplitGraph type and some of the functions used below are in the SplitGraph submodule of TreeKnit. Access them by calling using TreeKnit.SplitGraph and preceding the calls by SplitGraph.","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The SplitGraph is a directed graph that is based on both trees, and has two kind of nodes: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"leaf nodes correspond to leaves of the trees, and are identified by integers.  They have as many ancestors as there are trees in the SplitGraph. \ninternal nodes, called SplitNodes, correspond to internal nodes in one of the two trees. A color::Int attribute identifies the tree to which they belong (e.g. 1 for the first tree, 2 for the second, etc...). They have only one ancestor, of the same color.  Importantly, they are identified by the ensemble of leaf nodes that are \"below\" them, that is the subset of all their direct and indirect offsprings that are leaves.  As such, they uniquely correspond to a split in one of the two trees.  This information is stored as an array of integer in their conf field. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Let us now build the SplitGraph object: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"using TreeKnit.SplitGraph\ng = SplitGraph.trees2graph(treelist); \ng.labels_to_int","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"warning: Warning\nIt is recommemded that you add ; to the end of lines when working with SplitGraph, SplitNode or LeafNode in the REPL.  If you forget, you will quickly see why :-) ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We now see that the three leaves from our coarse-grained trees have been given an integer index in the SplitGraph.    Let us take a look at the internal nodes above the leaf MCC_3: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"a1 = g.leaves[g.labels_to_int[\"MCC_3\"]].anc[1]; # Ancestor for the first tree\na2 = g.leaves[g.labels_to_int[\"MCC_3\"]].anc[2]; # Ancestor for the second tree\n[a1.color, a2.color] # a1 and a2 resp. belong to trees 1 and 2\na1.conf # list of leaves below `a1`. Among those is the index for \"MCC_3\".\n[g.labels[i] for i in a1.conf] # Same as above, with labels\n[g.labels[i] for i in a2.conf] # and the same for a2 ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We now immediately see that the internal nodes above MCC_3 in the two trees define different splits: (MCC_1, MCC_3) in the first tree is different from (MCC_2, MCC_3) in the second tree. This is the idea underlying the inference of MCCs. ","category":"page"},{"location":"opttrees/#Counting-incompatibilities","page":"opttrees","title":"Counting incompatibilities","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"In the example above, the ancestors of leaf MCC_3 in the two trees define different splits: this is called an incompatibility.    Examination of the trees reveals that there are also similar incompatibilities for the two other leaves MCC_1 and MCC_2.    This can be computed using the count_mismatches function: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"SplitGraph.count_mismatches(g)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We indeed find 3 mismatches, one for each leaf. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"However, it is possible to explain the two example trees using less than three reassortments.    What would happen for example if we removed MCC_1 from both trees?    The first non-trivial split above leaf MCC_3 in both trees would then be (MCC_2, MCC_3), and the same goes for leaf MCC_2.    The number of incompatibilities would then go down to 0.  \"Removing\" leaves from the trees, or the graph, is done by defining a configuration: an array of booleans that stores the presence or absence of each leaf.    To remove MCC_1, we simply design a configuration that has 0 at the index corresponding to MCC_1: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"  conf = ones(Bool, length(g.leaves))\n  conf[g.labels_to_int[\"MCC_1\"]] = false # Remove `MCC_3` from the configuration\n  conf","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"To compute the number of incompatibilities given a configuration, we use the compute_energy function. The result is interpreted as the \"energy\" of this configuration given the graph g: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"SplitGraph.compute_energy(conf, g)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"info: Info\nThe function count_mismatches(g) shown above is a simple shortcut for conf = ones(Bool, length(g.leaves))\nSplitGraph.compute_energy(conf, g)In other words, it computes the energy for the configuration where all leaves are present. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"By removing a leaf, i.e. by \"enforcing\" a reassortment right above it, we've reduced the number of incompatibilities for the remaining leaves to 0.    Since removing a leaf corresponds to \"enforcing\" a reassortment, we have to assign a cost to it, that we call gamma.    This defines a score for each configuration, defined as the difference between the energy of the configuration and gamma times the number of leaves that were removed. Depending on the value of gamma, the difference in overall score associated to removing a leaf or keeping it will change from negative to positive.    Scores are computed with the compute_F function that takes gamma as its last argument.   Here are the differences in scores before and after removing MCC_3, for different values of gamma:   ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"conf0 = ones(Bool, length(g.leaves)) # Configuration with all leaves\nSplitGraph.compute_F(conf, g, 1) - SplitGraph.compute_F(conf0, g, 1)\nSplitGraph.compute_F(conf, g, 2) - SplitGraph.compute_F(conf0, g, 2)\nSplitGraph.compute_F(conf, g, 3) - SplitGraph.compute_F(conf0, g, 3)\nSplitGraph.compute_F(conf, g, 4) - SplitGraph.compute_F(conf0, g, 4)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"For this simple example, gamma = 3 is the \"critical\" value above which removing MCC_3 or any other leaf is not considered a good move.    The inference of MCCs for gamma leq 3 and gamma  3 will thus give different results.    In the first case, two MCCs will be found, corresponding to one reassortment event (above MCC_3 for instance) .    In the second, three MCCs and three reassortments will be found. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"run_treeknit!(t1, t2, OptArgs(γ=3.1))\nrun_treeknit!(t1, t2, OptArgs(γ=2.9))","category":"page"},{"location":"opttrees/#Simulated-annealing","page":"opttrees","title":"Simulated annealing","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The opttrees function attempts to find the configuration, i.e. a set of leaves to remove, that minimizes the incompatibility score presented above.    Since this is a discrete optimization problem with no clear mathematical formalization, we choose to use the simulated annealing technique.  Let us find an optimal configuration for our simple trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trange = reverse(1e-3:1e-2:1) # Cooling schedule\nM = 10 # Number of iterations per temperature value\nopt_confs = SplitGraph.sa_opt(g; Trange, M, γ = 2)[1]","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We find three optimal configurations, each corresponding to removing one leaf.    This indeed corresponds to the three possible single-reassortment explanations that we could give to reconcile the two trees.    Without branch length information, it is impossible to choose between one of these three optimas: the problem is degenerate.    A likelihood based way to break this degeneracy using branch length is described here.","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"For now, let's imagine that we have chosen the first configuration as our best solution.    Let's now map it back onto the initial trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"removed_leaves = g.labels[.!opt_confs[1]] # Expressed with coarse grained leaves\n# `mcc_names` was defined above\nremoved_clades = [mcc_names[x] for x in removed_leaves]","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"What this means is that we have just inferred all elements in removed_clades (just one in our case) to be MCCs.    Of course, in this simple example, it is straight forward to see that the other MCC simply consists of all the remaining leaves in the original trees.    This can also be deduced from the fact that the energy of all the optimal configurations is 0.  However, in the general case, some incompatibilities will remain even after simulated annealing.    For this reason, the opttrees function only outputs MCCs that have been identified by having removed them from the tree, i.e. by having enforced a reassortment above their root node.    If the trees that remain after having pruned these MCCs still have incompatibilities, the process described here needs to be iterated.    This is performed by the runopt function. ","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Using-the-CLI","page":"Overview","title":"Using the CLI","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"TreeKnit offers a simple CLI script: treeknit.  It takes two or more trees as input, passed as Newick files, and infers reassortment events between all pairs of trees.  It does this by finding shared regions of two trees, so called maximally compatible clades (MCCs), within which we assume no reassortment has occurred.  Each MCC corresponds to one reassortment event between the two trees. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"When exactly two trees are given as input, TreeKnit additionally returns an Ancestral Reassortment Graph (ARG) that combines the two trees.  This is currently not possible for multiple trees, more information on how TreeKnit runs on more than two trees can be found in the MultiTreeKnit section).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"info: Compile time\nJulia is compiled just in time, meaning that functions are compiled when called for the first time inside a julia session. For this reason, some compilation will take place each time the  treeknit script is called, leading to an overhead of a few seconds. If Treeknit is to be applied to many pairs of trees, it will be faster to use it from a Julia session. ","category":"page"},{"location":"overview/#Input","page":"Overview","title":"Input","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Inputs to treeknit are files containing trees in Newick format.  The only strict condition on the trees is that they share their leaf nodes.  Example: ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"treeknit tree1.nwk tree2.nwk","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"There are other important requirements for input trees, highlighted below.  They are not strict conditions in the sense that the algorithm will not fail if they are not met.  However, not meeting them might result in irrelevant or meaningless output. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Insignificant branches\nTree builders sometimes introduce branches of insignificant length in order to resolve polytomies and obtain binary trees. Since TreeKnit relies on topological differences between trees, and all internal nodes of input trees are interpreted as hard topological constraints. It is therefore important to remove low support branches/internal nodes prior to passing the trees to treeknit. This is most easily done by removing every branch that is not supported by at least one mutation, e.g. branches shorter than (L2)^-1, where L is the length of the sequences. Additionally, internal nodes with a low bootstrap value (typically 75) can be remove for additional robustness. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Rooting the trees\nTreeKnit depends on how the trees are rooted. It is important that the two trees are rooted in a consistent way. We recommend using the same outgroup for rooting both trees.","category":"page"},{"location":"overview/#Output","page":"Overview","title":"Output","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Output of the inference is written to the directory treeknit_results. This can be changed using the --outdir option.    The directory will contain:    ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"the MCCs, i.e. shared regions for paris of trees. The MCCs of all tree pairs are written in JSON format.  The example below shows possible MCCs for three trees of 10 leaves named a, b and c. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"{ \n    \"MCC_dict\" : {\n        \"1\": { \n            \"trees\":[\"a\", \"b\"],\n            \"mccs\": [[\"5_0\", \"6_0\"],[\"10_0\", \"1_0\", \"2_0\", \"3_0\", \"4_0\", \"7_0\", \"8_0\", \"9_0\"]]\n            },\n        \"2\": { \n            \"trees\":[\"a\", \"c\"],\n            \"mccs\": [[\"1_0\", \"8_0\", \"9_0\"],[\"10_0\", \"2_0\", \"3_0\", \"4_0\", \"5_0\", \"6_0\", \"7_0\"]]\n            },\n        \"3\": { \n            \"trees\":[\"b\", \"c\"],\n            \"mccs\": [[\"5_0\", \"6_0\"],[\"1_0\", \"8_0\", \"9_0\"],[\"10_0\", \"2_0\", \"3_0\", \"4_0\", \"7_0\"]]\n        }\n    }\n}","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"resolved trees: polytomies in each tree can be resolved using information coming from the other trees and from the MCCs (see the resolving section) They are written to files with the label _resolved added behind the original tree file name, e.g. tree_ha_resolved.nwk. \na file with all parameters used by TreeKnit during inference titled parameters.json.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In addition, when TreeKnit is called on exactly two trees the directory will contain a separate ARG folder with:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"the ARG, written as an extended Newick string.    \nliberally resolved trees needed for the construction of an ARG, see resolving section. The output will be written to a file with the label _liberal_resolved added behind the tree label, e.g. tree_ha_liberal_resolved.nwk. \na table with the correspondence between internal nodes of the ARG and the trees. Note that this refers to node labels of the liberally resolved trees, which may not be the same as the ones given as input.   ","category":"page"},{"location":"overview/#Options","page":"Overview","title":"Options","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"We present two methods for running TreeKnit, however it is possible to specify all parameters combinations for each individual use-case.","category":"page"},{"location":"overview/#TK_method_options","page":"Overview","title":"TreeKnit run methods","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"--better-trees: This method is recommended for most users using >2 trees and is also the fastest. It will attempt to resolve all trees compatibly before inferring MCCs, it will then run 1 round of pair-wise treeknit inference on all tree pairs individually - not further resolving trees. This technique has been optimized for sensitivity in MCC inference and polytomy resolution, minimizing the false positive rate for shared branches and new splits, but increasing the false negative rate, i.e. typically inferring too many reassortment events. \n--better-MCCs: This method is recommended for users using 2 trees, or users who are more interested in inferring accurate MCCs. It will also attempt to resolve all trees compatibly before inferring MCCs, it will then run 1 round of sequential treeknit inference on all tree pairs, further resolving trees using the MCCs inferred in the previous treeknit calls. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"For K2 trees it will then run one final round of pairwise TreeKnit on all tree pairs individually - not further resolving trees (this is required for K2 trees to ensure the accuracy of the output MCCs). This technique is optimized for MCC accuracy, however the output trees will potentially have a higher rate of inaccurate splits, this rate will increase with the number of trees. If more than 2 trees are given as input it will one run one last round of TreeKnit on all tree pairs without resolution.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Options that you can play with are:  ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"--gamma or -g: the parsimony parameter gamma (see here).\n--naive: naive inference. Using this flag is equivalent to setting gamma rightarrow infty.  \n--seq-lengths: length of sequences used to infer trees. These are used for likelihood tests to break degeneracy between topologically equivalent MCCs.  \n--no-likelihood: do not use branch length to sort the likelihood of different MCCs.\n--no-resolve: do not attempt to resolve trees during and after tree-pair MCC inference.\n--parallel: run sequential MultiTreeKnit with parallelization (only used for 3 or more trees).\n--auspice-view: will create files that can be used to view a tanglegram of the two trees with colored maximally compatible clades in auspice. For more information see Visualization of MCCs in a tanglegram.\n--verbosity-level: see the verbosity section for information. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Additional options can be used for \"advanced users\":","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"rounds: number of rounds of TreeKnit. Trees are resolved in each TreeKnit run (except in the final round when there are more than 2 trees, the --resolve-all-rounds can be used to modify this behavior), meaning subsequent rounds can give different results. This is especially useful for more than two trees, see MultiTreeKnit.\n--no-pre-resolve: do not compatibly resolve all trees with each other before inferring MCCs (default is to pre-resolve).\n--resolve-all-rounds: resolve trees before inferring pairwise MCCs in all rounds Overrides --no-resolve. Default for 2 trees. For more than 2 trees the default is to not resolve in the final round.\n--liberal-resolve: use liberal resolving method, see here. In short, with this option, TreeKnit will try to resolve trees as much as possible even in ambiguous situations. It results in more resolved trees but also more wrong splits. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"More details on the options can be found throughout the documentation.  In particular, the parsimony parameter is explained here and resolution of trees here.","category":"page"},{"location":"overview/#Using-from-a-Julia-session","page":"Overview","title":"Using from a Julia session","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: For two trees only\nFor more than two trees, the process is different. A plan for the future is to \"uniformize\" the way TreeKnit is called for 2 or more trees. So what's below may be deprecated then. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"If TreeKnit has to be used on several datasets and speed is important, then you should call it from a julia session directly.  Let's see how one does this for a simple two tree example using the example directory, which contains two Newick files tree_h3n2_ha.nwk and tree_h3n2_na.nwk. We shall use the --better-MCCs method, which is the default for 2 trees. First, read the trees: ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using TreeTools\nusing TreeKnit\nt_ha = read_tree(dirname(pathof(TreeKnit)) * \"/../examples/tree_h3n2_ha.nwk\", label=\"ha\")\nt_na = read_tree(dirname(pathof(TreeKnit)) * \"/../examples/tree_h3n2_na.nwk\", label=\"na\")","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"info: Tree Labels\nWhen computing the MCCs for tree pairs TreeKnit uses a tree's label as a unique identifier. These labels are also written to the output MCCs.json file. When TreeKnitis used via the command line the filename and/or folder name is used as a label for the input trees if these are unique, otherwise an error is thrown. When using TreeKnit from a julia session, trees will be assigned a random unique string as an identifying label. One can change this by calling label!(tree, some_label), see the TreeTools documentation ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We run treeknit in the repl using the command: run_treeknit! (it takes an optional argument object OptArgs, with which we can specify inference parameters) the command does the following:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"By default, TreeKnit resolves all trees with each other prior to inference unless --no-pre-resolve is activated (equivalent to setting pre_resolve=false in the OptArgs). \nCompute the MCCs of the two trees, by default MCCs are inferred up to resolution, this can be deactivated with the --no-resolve flag (equivalent to setting resolve=false in the OptArgs). See MCCs for more details.\nResolve the two trees using the inferred MCCs. This can also be deactivated with the --no-resolve flag. \nLadderize the first input tree, and sort the polytomies of two trees w.r.t to the MCCs, allowing for ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"clearer Visualization (e.g. tanglegrams).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"info: pre-resolve and resolve\nNote thatresolve=true will also resolve trees with each other prior to inference, and thus pre_resolve is not needed for 2 trees if resolve=true, but we distinguish between the two options for consistency with with K2 tree-case.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"For two trees we can additionally compute the ARG from the resolved trees and the MCCs, note ARG reconstruction will potentially further resolve trees, adding ambiguous splits in a manner that is more parsimonious, using liberal resolution.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"MCCs = run_treeknit!(t_ha, t_na, OptArgs(;pre_resolve=true, resolve=true, strict=true)) # compute MCCs, resolve trees\narg, rlm, lm1, lm2 = SRG.arg_from_trees(t_ha, t_na, MCCs.mccs[Set([\"ha\", \"na\"])]); # compute the ARG and mappings from tree to ARG internal nodes. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To write these results to files, use the following commands: ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"write(\"arg.nwk\", arg) # write the ARG\nwrite_mccs(\"MCCs.json\", MCCs) # write the MCCs\nwrite_newick(\"tree_ha_ARG_resolved.nwk\", t_ha) # write resolved HA tree","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Note that the treeknit function in src/cli.jl follows exactly these steps for two trees, for multiple trees see the MultiTreeKnit section. Have a look at it for a more detailed example of how to use this package from inside julia. ","category":"page"},{"location":"options/#options","page":"Important options","title":"Options","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"run_treeknit! uses a topogy based heuristic optimization to find maximally compatible clades.    Options to this heuristic are provided through the OptArgs object, that is optionally passed as a second argument.   Essential options are detailed here. \t","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"Note that when the OptArgs() object is initialized it's default parameters are the same as those for running TreeKnit for 2 trees. When instead the constructor OptArgs(K::Int) is called, the default parameters for running TreeKnit with K trees are returned. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"The default parameters for K=2 trees are the parameters for the :better_MCCs method, whereas the default parameters for K>2 trees are the parameters for the :better_trees method. See TreeKnit Methods.","category":"page"},{"location":"options/#gamma","page":"Important options","title":"Parsimony parameter","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"The heuristic method used by TreeKnit tries to prune consistent clades from a pair of trees in order to increase a compatibility score between other clades.    Pruning a clade is interpreted as fixing a reassortment right above it, while increasing the compatibility between remaining clades removes reassortments.    A purely parsimonious heuristic should thus give the same weight to fixing a reassortment through pruning a clade and fixing one incompatibility in the trees. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"Here, we assign the score gamma to each pruned clade, and count as 1 each incompatibility fixed for the remaining clades.    For gamma=1, we obtain a parsimonious method that attempts to minimize the overall number of reassortments.    For higher values, pruning a clade must \"fix\" at least gamma incompatibilities to be considered a good move, making the obtained MCCs less parsimonious.    For infinite gamma, pruning clades is impossible, and we fall back on the naive estimation of MCCs. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"The example below illustrates the difference between different gamma values: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"using TreeKnit # hide\nt1 = parse_newick_string(\"((((A,B),C),D),E);\"; label=\"t1\")\nt2 = parse_newick_string(\"((((D,B),E),A),C);\"; label=\"t2\") # Same topology, but shuffled leave\nnothing # hide","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"Here, pruning the two leaves (A,C) or (D,E) results in compatible trees (resp. ((B,D),E) and ((A,B),C)).    These moves each have a cost 2gamma (removing 2 clades), but bring us from trees with 5 incompatibilities to 0.    They will only be accepted if gamma leq 25. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"run_treeknit!(t1, t2, OptArgs(γ=2))\nrun_treeknit!(t1, t2, OptArgs(γ=3))","category":"page"},{"location":"options/#Resolving-trees-with-polytomies","page":"Important options","title":"Resolving trees with polytomies","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"See Resolving for more information about tree resolution. Note we have multiple options for resolving trees:","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"pre_resolve: if this option is passed to run_treeknit! (through OptArgs), resolve! will be called on all trees together prior to MCC inference. \nresolve: under this option resolve! is called on each pair of trees before each iteration of the MCC inference procedure. For example if treeknit is run on trees t1, t2 and t3 and resolve is set to true, resolve! will be called on each combination of tree pairs (see MultiTreeKnit for more details).  Furthermore, this option allows for tree resolution during MCC inference on tree pairs and will resolve trees after each pair-wise iteration of TreeKnit using the inferred MCCs.","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"info: pre-resolve and resolve for tree pairs\nNote thatresolve=true will also resolve trees with each other prior to inference, and thus pre_resolve is not needed for 2 trees if resolve=true, but we distinguish between the two options for consistency with 2 trees).","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"When resolving trees using MCCs we distinguish between two options (see strict vs liberal resolution for a detailed description of the two methods):","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"strict=true: only add unambiguous splits from one tree into another.\nstrict=false also known as liberal resolve: will resolve trees as much as possible, fully resolving shared regions of the two trees, but arbitrarily choosing the location of ambiguous splits, leading to potentially wrong splits in the output trees. ","category":"page"},{"location":"options/#likelihood","page":"Important options","title":"Degeneracy: sorting with likelihood","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"When several MCC decompositions are possible, degeneracy is removed by using the likelihood_sort option (activated by default).  In the example below, there are three equivalent decompositions if only topology is considered: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"using TreeKnit # hide\nt1 = parse_newick_string(\"((A:2,B:2):2,C:4);\")\nt2 = parse_newick_string(\"(A:2,(B:1,C:1):1);\")\noa = OptArgs(likelihood_sort = false)\nunique([run_treeknit!(t1, t2, oa).mccs[Set([t1.label, t2.label])] for rep in 1:50]) # Repeating computation many times ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"When taking branch lengths into account, this degeneracy vanishes: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"oa = OptArgs(likelihood_sort = true)\nunique([run_treeknit!(t1, t2, oa).mccs[Set([t1.label, t2.label])] for rep in 1:50])","category":"page"},{"location":"options/#Verbosity","page":"Important options","title":"Verbosity","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"The TreeKnit cli has four level of verbosity that can be set with the --verbosity-level <value> option: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"-1 means no visible output\n0 means relatively little output: e.g. input file names, number of MCCs found,... The default options result in less than 10 lines.\n1 gives slightly more details: e.g. the MCC inference process for each pair of trees is detailed\n2 gives a lot of information and is only useful for debugging and when using small trees ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"The --verbose or -v flag set the verbosity to 1 instead of 0. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"When using from a julia session, it can be useful to also set the verbosity.  Let's take the simple case where one wants to use run_treeknit!(tree1, tree2, OptArgs()) with some pre-loaded trees and default arguments.  If run like this, no info will be shown.  To trigger verbosity, create a custom logger in the following way: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"using TreeKnit, TreeTools, Logging\nt1 = parse_newick_string(\"((A:2,B:2):2,C:4);\"; label=\"t1\");\nt2 = parse_newick_string(\"(A:2,(B:1,C:1):1);\"; label=\"t2\");\nverbosity = 1;\nlogger = ConsoleLogger(LogLevel(-verbosity)) # corresponds to `--verbosity-level 1` from the CLI\noutput = with_logger(logger) do \n  run_treeknit!(t1, t2, OptArgs())\nend","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"The above works because during inference, TreeKnit emits log messages in the form @logmsg LogLevel(0/-1/-2) msg.  The default Julia logger will only show messages with a positive level, and this can be set as described above.  See the Logging and the LoggingExtras package for more information. ","category":"page"},{"location":"#TreeKnit","page":"Index","title":"TreeKnit","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"TreeKnit is a julia package that performs inference of reassortment events in segmented genomes, such as human influenza. Additionally, it can reconstruct Ancestral Reassortment Graphs for segment pairs. ","category":"page"},{"location":"#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"You can simply install TreeKnit using the julia package manager (if you don't have julia, you can get it from here): ","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.add(\"TreeKnit\")","category":"page"},{"location":"","page":"Index","title":"Index","text":"You should now be able to use using TreeKnit from inside julia. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"info: TreeTools package\nIf you are going to use TreeKnit from inside a julia session, you will very likely need the TreeTools package to read Newick tree files in a format that TreeKnit takes as input. You can get TreeTools by typing Pkg.add(\"TreeTools\") from a julia console. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"To use the CLI (Linux/Mac users), build the package by calling ","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.build(\"TreeKnit\")","category":"page"},{"location":"","page":"Index","title":"Index","text":"This will add executable scripts to your ~/.julia/bin folder.  Simply add this folder to your path to call the script, e.g. export PATH=\"$HOME/.julia/bin:$PATH\".  You should now be able to call, e.g., treeknit --help.","category":"page"},{"location":"types/","page":"Objects","title":"Objects","text":"CurrentModule = TreeKnit","category":"page"},{"location":"types/#The-OptArgs-object","page":"Objects","title":"The OptArgs object","text":"","category":"section"},{"location":"types/","page":"Objects","title":"Objects","text":"run_treeknit! and several other functions take an OptArgs object that controls several parameters of the inference process. ","category":"page"},{"location":"types/","page":"Objects","title":"Objects","text":"OptArgs","category":"page"},{"location":"types/#TreeKnit.OptArgs","page":"Objects","title":"TreeKnit.OptArgs","text":"struct OptArgs\n\nStoring parameters for SplitGraph.runopt function.\n\nGeneral\n\nγ::Real = 2\nitmax::Int64 = 15: maximal number of iterations of naive MCCs / SA cycles.\nlikelihood_sort::Bool = true: sort equivalent configurations using likelihood test based on branch length.\nresolve::Bool = true: try to resolve trees while finding MCCs.\nstrict::Bool = true: only resolve unambiguous splits\nseq_lengths: lengths of sequences that trees were built from. Used in likelihood calculations. This is initialized from other input arguments, and defaults to sequences of length one.\n\nPipeline options - necessary for K>2 trees\n\npre_resolve::Bool = true: pre-resolve all trees using each other prior to MCC inference\nrounds::Int=1: #rounds of MCC inference and tree resolution on all tree pairs\nfinal_no_resolve::Bool = false: do not resolve in the final round of pair-wise MCC inference\nparallel::Bool = false: parallelize MCC inference as much as possible. \n\nSimulated annealing\n\nnMCMC::Int = 25: The total number of MCMC steps (swaps) for a tree of n leaves is nMCMC*n.  The number of MCMC steps at one temperature is nMCMC * n / nT.\ncooling_schedule = :geometric: type of cooling schedule (:geometric, :linear, :acos)\nTmin::Float64 = 0.05: minimal temperature of SA.\nTmax::Float64 = 0.8: maximal temperature of SA.\nnT::Int = 3000: number of steps in the cooling schedule\n\n\n\n\n\n","category":"type"},{"location":"types/#The-MCC_set-object","page":"Objects","title":"The MCC_set object","text":"","category":"section"},{"location":"types/","page":"Objects","title":"Objects","text":"We define an MCC_set object to store the inferred MCCs of multiple trees.","category":"page"},{"location":"types/","page":"Objects","title":"Objects","text":"MCC_set","category":"page"},{"location":"types/#TreeKnit.MCC_set","page":"Objects","title":"TreeKnit.MCC_set","text":"struct MCC_set\n\nstructure to store and access computed MCCs for tree pairs\n\nno_trees: number of trees\norder_trees: Vector of tree.labels, order of calculations: Combinatorics.combinations(1:length(trees), 2)\nmccs: Dictionary of calculated mccs, key is set of labels of trees in each tree pair\n\nAdd and retrieve mccs with get! and add! and Tuple or Vararg of tree labels or position of tree labels in order_trees\n\n\n\n\n\n","category":"type"}]
}
