var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Functions","title":"Functions","text":"CurrentModule = TreeKnit\nDocTestSetup  = quote\n    using TreeTools\nend\t","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"functions/#Function-used-for-the-CLI","page":"Functions","title":"Function used for the CLI","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"TreeKnit.treeknit","category":"page"},{"location":"functions/#TreeKnit.treeknit","page":"Functions","title":"TreeKnit.treeknit","text":"treeknit\n\nArguments\n\nnwk1: Newick file for first tree\nnwk2: Newick file for second tree\n\nOptions\n\n-o, --outdir <arg>: directory for results; Example -o=treeknit_results\n-g, --gamma <arg>: value of γ; Example -g=2\n--seq-lengths <arg>: length of the sequences. Example: --seq-length \"1500 2000\"\n--n-mcmc-it <arg>: number of MCMC iterations per leaf; default 25\n\nFlags\n\n--naive: Naive inference (overrides -g).\n--no-likelihood: Do not use branch length likelihood test to sort between different MCCs\n--no-resolve: Do not attempt to resolve trees before inferring MCCs.\n-v, --verbose: verbosity\n\n\n\n\n\n","category":"function"},{"location":"functions/#Computing-Maximal-Compatible-Clades-(MCCs)-for-pairs","page":"Functions","title":"Computing Maximal Compatible Clades (MCCs) for pairs","text":"","category":"section"},{"location":"functions/#Main-functions","page":"Functions","title":"Main functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"computeMCCs","category":"page"},{"location":"functions/#TreeKnit.computeMCCs","page":"Functions","title":"TreeKnit.computeMCCs","text":"computeMCCs(\n\tt1::Tree, t2::Tree, oa::OptArgs = OptArgs();\n\tnaive = false, seqlengths = [1,1],\n)\n\nCompute pairwise MCCs for trees. Return MCCs and resolved splits. The computeMCCs! version resolves the input trees with newly found splits.\n\nInputs\n\noa::OptArgs\n\nControls parameters of the MCC inference (unless naive=true). See ?OptArgs for details.\n\nIn general, this should be set to true if more than two trees are used, and to false   for only two trees (for speed).\n\nnaive = false\n\nIf true, use a naive estimation for MCCs, i.e. find all clades that have an exactly matching topology in all trees.\nElse, use a pseudo-parsimonious method based (mostly) on topology. The method runopt(oa,t1,t2) is called on every pair of trees.\n\n\n\n\n\n","category":"function"},{"location":"functions/#For-pairs-of-trees-only","page":"Functions","title":"For pairs of trees only","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"naive_mccs\nTreeKnit.runopt","category":"page"},{"location":"functions/#TreeKnit.naive_mccs","page":"Functions","title":"TreeKnit.naive_mccs","text":"naive_mccs(treelist)\n\nFind sets of nodes which are:\n\nclades in all trees of treelist,\nall subclades of nodes are clades in all trees of treelist (both of these properties define consistency),\nmaximal: adding a node to a set results it in not being a clade in at least one of the trees.\n\nAll the trees of treelist should share the same leaf nodes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#TreeKnit.runopt","page":"Functions","title":"TreeKnit.runopt","text":"\trunopt(t1::Tree, t2::Tree; kwargs...)\n\trunopt(oa::OptArgs, t1::Tree, t2::Tree)\n\trunopt(oa::OptArgs, trees::Dict{<:Any,<:Tree})\n\nRun optimization at constant γ. See ?Optargs for arguments. In the first form, keyword   arguments are given to OptArgs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Resolving-trees","page":"Functions","title":"Resolving trees","text":"","category":"section"},{"location":"functions/#Using-topology","page":"Functions","title":"Using topology","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"resolve!(::TreeTools.Tree, ::TreeTools.Tree)","category":"page"},{"location":"functions/#TreeKnit.resolve!-Tuple{TreeTools.Tree, TreeTools.Tree}","page":"Functions","title":"TreeKnit.resolve!","text":"resolve!(t1::Tree, t2::Tree; tau=0.)\n\nResolve t1 using splits of t2 and inversely. Every split of t2 a tree that is compatible with t1 is introduced in t1 with branch length tau (and inversely). Return new splits in each tree.\n\n\n\n\n\n","category":"method"},{"location":"mccs/#MCCs","page":"MCCs","title":"Maximally Compatible Clades","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"TreeKnit reconstructs the ARG from trees by first inferring Maximally Compatible Clades (MCC). ","category":"page"},{"location":"mccs/#Handling-trees","page":"MCCs","title":"Handling trees","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"Functions that directly handle trees are found in the separate TreeTools package.    Here is a short list of useful ones: ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"read_tree(file): read tree from newick file, return Tree object. \nparse_newick(string): parse newick string into a TreeNode object.\nnode2tree(n::TreeNode): create a Tree object from node n, using it as a root. \nwrite_newick(file::String, t::Tree)/write_newick([file::String], n::TreeNode): write tree to file using newick format. Return a newick string if file is not provided. ","category":"page"},{"location":"mccs/#Simple-case","page":"MCCs","title":"Simple case","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"Let's see how to infer Maximally Compatible Clades (MCC) for a very simple case: two trees with five leaves. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"using TreeKnit\nt1 = node2tree(parse_newick(\"((A,B),(C,(D,X)))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),(C,D))\"))","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"The computeMCCs function takes two trees as input. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"mccs = computeMCCs(t1, t2)","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"Individual MCCs are simply arrays containing labels of leaves of the trees.  ","category":"page"},{"location":"mccs/#Interpretation-of-results","page":"MCCs","title":"Interpretation of results","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"The genealogy of two RNA segments subject to reassortment is described by an Ancestral Reassortment Graph (ARG).  An ARG is a directed graph that represents the lineage of a given pair of segments by coalescence of nodes, as in a genealogical tree, but also shows reassortment events and the exchange of segments by nodes that have two ancestors.  Since reassortments only occur between segments, the genealogy of given segment is described by a tree.  As a result, the ARG must embed both segment-trees, and every branch in the ARG has to belong to either one of the trees, or to both. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"TreeKnit infers the ARG by finding the branches that are common to both trees.  Given two trees with potentially different topologies, it tries to \"glue\" them together in a reasonable way, where the interpretation of reasonable can vary between parsimonious and conservative (see the parsimony parameter gamma). ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"The MCCs returned by computeMCCs represent regions of the ARG (and of the segment trees) where branches are common to both trees.  In other words, these are the regions where the two segment trees must be \"glued together\".  Given those regions and the knowledge of the trees, it is possible to unambiguously reconstruct the genealogy. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"info: Number of reassortments in the genealogy\nWhen going up the ARG (backwards in time), a reassortment consists of passing from a region where branches are common to the two trees to a region where they are not. It is a split of branches.  As a consequence, the root of each MCC must be a reassortment, with the exception of an MCC containing the root of both trees.  The number of reassortments events in the inferred ARG can thus simply be obtained by counting the number of MCCs, potentially removing the one that contains the roots of both trees if it exists. ","category":"page"},{"location":"mccs/#naive_mccs","page":"MCCs","title":"Naive estimation","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"It is also possible to compute a \"naive\" estimation of MCCs using the naive keyword.    When naive is set to true, computeMCCs returns maximum clades that are exactly compatible between pairs of trees: ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"using TreeKnit # hide\nt1 = node2tree(parse_newick(\"(((A1,A2),(B1,B2)),(C1,C2))\"))\nt2 = node2tree(parse_newick(\"(((A1,A2),(C1,C2)),(B1,B2))\"))\ncomputeMCCs(t1, t2; naive=true)","category":"page"},{"location":"opttrees/#opttrees","page":"opttrees","title":"The opttrees function","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The core of the heuristic TreeKnit is based on happens in the opttrees function, found in the SplitGraph submodule.    Given two trees, opttrees attempts to reconcile them by pruning certain clades.    A quick description of different steps in this function is given here, with the two simple trees below as an example case: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"using TreeKnit# hide\nnwk1 = \"(((A1:1,A2:2):2,(B1:2,(B2:1,B3:1):1):2):2,(C1:1,C2:2):4)\";\nnwk2 = \"((A1:1,A2:2):2,((B1:2,(B2:1,B3:1):1):1,(C1:1,C2:2):1):1)\";\nt1 = node2tree(parse_newick(nwk1))\nt2 = node2tree(parse_newick(nwk2))\nnothing # hide","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trees are not displayed here for space reasons, but you're encouraged to draw them if you want to follow along! ","category":"page"},{"location":"opttrees/#Coarse-graining-of-naive-MCCs","page":"opttrees","title":"Coarse-graining of naive MCCs","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"As a first step, naive MCCs are computed for input trees using the naive_mccs function.    Here, we find three clades that are already compatible between the two trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"treelist = Any[t1, t2]\nmcc = naive_mccs(treelist)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trees are then \"reduced\" to those MCCs: new trees are built where each leaf corresponds to one of the naive MCCs.    The reduced trees have incompatibilities at the leaf level: it is no longer possible to group some of their leaves together in a consistent clade.  ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"mcc_names = TreeKnit.name_mcc_clades!(treelist, mcc)\nfor (i,t) in enumerate(treelist)\n\ttreelist[i] = TreeKnit.reduce_to_mcc(t, mcc)\nend\nnothing # hide","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The trees in treelist are now a reduced form of t1 and t2, and the names of the new leaves correspond to clades in the original tree.    The mapping between leaf name and original clade is stored in mcc_names","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"treelist[1]\ntreelist[2]\nmcc_names","category":"page"},{"location":"opttrees/#The-SplitGraph-object","page":"opttrees","title":"The SplitGraph object","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Once the trees reduced to their naive MCCs, we construct a SplitGraph object from them. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"info: *SplitGraph* submodule\nThe SplitGraph type and some of the functions used below are in the SplitGraph submodule of TreeKnit. Access them by calling using TreeKnit.SplitGraph and preceding the calls by SplitGraph.","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The SplitGraph is a directed graph that is based on both trees, and has two kind of nodes: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"leaf nodes correspond to leaves of the trees, and are identifier by integers.  They have as many ancestors as there are trees in the SplitGraph. \ninternal nodes, called SplitNodes, correspond to internal nodes in one of the two trees. A color::Int attribute identifies the tree to which they belong (e.g. 1 for the first tree, 2 for the second, etc...). They have only one ancestor, of the same color.  Importantly, they are identified by the ensemble of leaf nodes that are \"below\" them, that is the subset of all their direct and indirect offsprings that are leaves.  As such, they uniquely correspond to a split in one of the two trees.  This information is stored as an array of integer in their conf field. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Let us know build the SplitGraph object: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"using TreeKnit.SplitGraph\ng = SplitGraph.trees2graph(treelist); \ng.labels_to_int","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"warning: Warning\nIt is recommemded that you add ; to the end of lines when working with SplitGraph, SplitNode or LeafNode in the REPL.  If you forget, you will quickly see why :-) ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We now see that the three leaves from our coarse-grained trees have been attributed an integer index in the SplitGraph.    Let us take a look at the internal nodes above the leaf MCC_3: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"a1 = g.leaves[g.labels_to_int[\"MCC_3\"]].anc[1]; # Ancestor for the first tree\na2 = g.leaves[g.labels_to_int[\"MCC_3\"]].anc[2]; # Ancestor for the second tree\n[a1.color, a2.color] # a1 and a2 resp. belong to trees 1 and 2\na1.conf # list of leaves below `a1`. Among those is the index for \"MCC_3\".\n[g.labels[i] for i in a1.conf] # Same as above, with labels\n[g.labels[i] for i in a2.conf] # and the same for a2 ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We now immediatly see that the internal nodes above MCC_3 in the two trees define different splits: (MCC_1, MCC_3) in the first tree is different from (MCC_2, MCC_3) in the second tree.    This is the idea underlying the inference of MCCs. ","category":"page"},{"location":"opttrees/#Counting-incompatibilities","page":"opttrees","title":"Counting incompatibilities","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"In the example above, the ancestors of leaf MCC_3 in the two trees define different splits: this is called an incompatibility.    Examination of the trees reveals that there are also similar incompatibilitie for the two other leaves MCC_1 and MCC_2.    This can be computed using the count_mismatches function: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"SplitGraph.count_mismatches(g)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We indeed find 3 mismatches, one for each leaf. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"However, it is possible to explain the two example trees using less than three reassortments.    What would happen for example if we removed MCC_1 from both trees?    The first non-trivial split above leaf MCC_3 in both trees would then be (MCC_2, MCC_3), and the same goes for leaf MCC_2.    The number of incompatibilities would then go down to 0.  \"Removing\" leaves from the trees, or the graph, is done by defining a configuration: an array of booleans that stores the presence or absence of each leaf.    To remove MCC_1, we simply design a configuration that has 0 at the index corresponding to MCC_1: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"  conf = ones(Bool, length(g.leaves))\n  conf[g.labels_to_int[\"MCC_1\"]] = false # Remove `MCC_3` from the configuration\n  conf","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"To compute the number of incompatibilities given a configuration, we use the compute_energy function. The result is interpreted as the \"energy\" of this configuration given the graph g: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"SplitGraph.compute_energy(conf, g)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"info: Info\nThe function count_mismatches(g) shown above is a simple shortcut for conf = ones(Bool, length(g.leaves))\nSplitGraph.compute_energy(conf, g)In other words, it computes the energy for the configuration where all leaves are present. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"By removing a leaf, i.e. by \"enforcing\" a reassortment right above it, we've reduced the number of incompatibilities for the remaining ones to 0.    Since removing a leaf corresponds to \"enforcing\" a reassortment, we have to assign a cost to it, that we call gamma.    This defines a score for each configuration, defined as the difference between the energy of the configuration and gamma times the number of leaves that were removed. Depending on the value of gamma, the difference in overall score associated to removing a leaf or keeping it will change from negative to positive.    Scores are computed with the compute_F function that takes gamma as its last argument.   Here are the differences in scores before and after removing MCC_3, for different values of gamma:   ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"conf0 = ones(Bool, length(g.leaves)) # Configuration with all leaves\nSplitGraph.compute_F(conf, g, 1) - SplitGraph.compute_F(conf0, g, 1)\nSplitGraph.compute_F(conf, g, 2) - SplitGraph.compute_F(conf0, g, 2)\nSplitGraph.compute_F(conf, g, 3) - SplitGraph.compute_F(conf0, g, 3)\nSplitGraph.compute_F(conf, g, 4) - SplitGraph.compute_F(conf0, g, 4)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"For this simple example, gamma = 3 is the \"critical\" value above which the fact of removing MCC_3 or any other leaf is not considered a good move.    The inference of MCCs for gamma leq 3 and gamma  3 will thus give different results.    In the first case, two MCCs will be found, corresponding to one reassortment event (above MCC_3 for instance) .    In the second, three MCCs and three reassortments will be found. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"computeMCCs(t1, t2, OptArgs(γ=3.1))\ncomputeMCCs(t1, t2, OptArgs(γ=2.9))","category":"page"},{"location":"opttrees/#Simulated-annealing","page":"opttrees","title":"Simulated annealing","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The opttrees function attempts to find the configuration, i.e. a set of leaves to remove, that minimizes the compatibility score presented above.    Since this is a discrete optimization problem with no clear mathematical formalization, we choose to use the simulated annealing technique.  Let us find optimum configurations for our simple trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trange = reverse(1e-3:1e-2:1) # Cooling schedule\nM = 10 # Number of iterations per temperature value\nopt_confs = SplitGraph.sa_opt(g; Trange, M, γ = 2)[1]","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We find three optimal configurations, each corresponding to removing one leaf.    This indeed corresponds to the three possible single-reassortment explanations that we could give to reconcile the two trees.    Without branch length information, it is impossible to choose between one of these three optimas: the problem is degenerate.    A likelihood based way to break this degeneracy using branch length is described here.","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"For now, let's imagine that we have chosen the first optimum configuration as our best solution.    Let's now map it back on the initial trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"removed_leaves = g.labels[.!opt_confs[1]] # Expressed with coarse grained leaves\n# `mcc_names` was defined above\nremoved_clades = [mcc_names[x] for x in removed_leaves]","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"What this means is that we have just inferred all elements in removed_clades (just one in our case) to be MCCs.    Of course, in this simple example, it is immediate to see that the other MCC simply consists of all the remaining leaves in the original trees.    This can also be deduced from the fact that the energy of all the optimal configurations is 0.  However, in the general case, some incompatibilities will remain even after simulated annealing.    For this reason, the opttrees function only outputs MCCs that have been identified by having removed them from the tree, i.e. by having enforced a reassortment above their root node.    If the trees that remain after having pruned these MCCs still have incompatibilities, the process described here needs to be iterated.    This is performed by the runopt function. ","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Using-the-CLI","page":"Overview","title":"Using the CLI","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"TreeKnit offers a simple CLI script: treeknit.  In short, it takes two trees as input, passed as Newick files, and returns an Ancestral Reassortment Graph. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"info: Compile time\nJulia is compiled just in time, meaning that functions are compiled when called for the first time inside a julia session. For this reason, some compilation will take place each time the  treeknit script is called, leading to an overhead of a few seconds. If Treeknit is to be applied to many pairs of trees, it will be faster to use it from a Julia session. ","category":"page"},{"location":"overview/#Input","page":"Overview","title":"Input","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Inputs to treeknit are two files containing trees in Newick format.  The only strict condition on the trees is that they share their leaf nodes.  Example: ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"treeknit tree1.nwk tree2.nwk","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Insignificant branches\nTree builders sometimes introduce branches of insignificant length in order to resolve polytomies and obtain binary trees. Since TreeKnit relies on topological differences between trees, it is important to remove these branches prior to passing the trees to treeknit. This can be done by using only branches with high bootstrap value (typically, 75), or by removing branches shorter than, e.g., (L2)^-1, where L is the length of the sequences. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Rooting the trees\nThe result TreeKnit depend how the trees are rooted. It is important that the two trees are rooted in a consistent way. We recommend using the same outgroup for rooting both trees.","category":"page"},{"location":"overview/#Output","page":"Overview","title":"Output","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Output of the inference is written a directory called treeknit_results. This can be changed using the --outdir option.    The directory will contain:   ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"the ARG, written as an extended Newick string.   \nthe MCCs, i.e. shared regions of the trees, indicated by the leaves they contain.  \nresolved trees, where polytomies have been reduced as much as possible using the knowledge of the MCCs.   \na table with the correspondence between internal nodes of the ARG and the trees. Note that this refers to node labels of the resolved trees, which may not be the same as the ones given as input.   ","category":"page"},{"location":"overview/#Options","page":"Overview","title":"Options","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The main options that you can play with are:  ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"the parsimony parameter gamma, --gamma or -g.   \nnaive inference --naive. Using this flag is equivalent to setting gamma rightarrow infty.  \nLength of sequences used to infer trees: --seq-lengths. These are used for likelihood test to break degeneracy between topologically equivalent MCCs.  ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"More details in the options section.","category":"page"},{"location":"overview/#Using-from-a-Julia-session","page":"Overview","title":"Using from a Julia session","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"If TreeKnit has to be used on several pairs of trees and speed is important, then you should call it from a julia session directly.  Let's see how one does this using the example directory, which contains two Newick files tree_h3n2_ha.nwk and tree_h3n2_na.nwk.  First, read the trees: ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using TreeTools\nusing TreeKnit\nt_ha = read_tree(dirname(pathof(TreeKnit)) * \"/../examples/tree_h3n2_ha.nwk\")\nt_na = read_tree(dirname(pathof(TreeKnit)) * \"/../examples/tree_h3n2_na.nwk\")","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We now proceed in three steps: ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Compute MCCs for these two trees. See the options or MCCs for more details.\nResolve the trees using these MCCs. \nCompute the ARG from the resolved trees and the MCCs. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"MCCs = computeMCCs(t_ha, t_na) # compute MCCs\nrS = resolve!(t_ha, t_na, MCCs); # resolve. Output `rS` contains the resolved splits\narg, rlm, lm1, lm2 = SRG.arg_from_trees(t_ha, t_na, MCCs); # compute the ARG and mappings from tree to ARG internal nodes. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To write these results to files, one could do ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"write(\"arg.nwk\", arg) # write the ARG\nwrite_mccs(\"mcc.dat\", MCCs) # write the MCCs\nwrite_newick(\"tree_ha_resolved.nwk\", t_ha) # write resolved HA tree","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Note that the treeknit function in src/cli.jl follows exactly these steps. Have a look at it for a more detailed example of how to use this package from inside julia. ","category":"page"},{"location":"options/#options","page":"Important options","title":"Options","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"computeMCCs uses a topogy based heuristic optimization to find maximally compatible clades.    Options to this heuristic are provided through the OptArgs object, that is optionally passed as a second argument.   Essential options are detailed here. \t","category":"page"},{"location":"options/#gamma","page":"Important options","title":"Parsimony parameter","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"The heuristic method used by TreeKnit tries to prune consistent clades from a pair of trees in order to increase a compatibility score between other clades.    Pruning a clade is interpreted as fixing a reassortment right above it, while increasing the compatibility between remaining clades removes reassortments.    A purely parsimonious heuristic should thus give the same weight to fixing a reassortment through pruning a clade and fixing one incompatibility in the trees. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"Here, we assign the score gamma to each pruned clade, and count as 1 each incompatibility fixed for the remaining clades.    For gamma=1, we obtain a parsimonious method that attempts to minimize the overall number of reassortments.    For higher values, pruning a clade must \"fix\" at least gamma incompatibilities to be considered a good move, making the obtained MCCs less parsimonious.    For infinite gamma, pruning clades is impossible, and we fall back on the naive estimation of MCCs. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"The example below illustrates the difference between different gamma values: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"using TreeKnit # hide\nt1 = node2tree(parse_newick(\"((((A,B),C),D),E)\"))\nt2 = node2tree(parse_newick(\"((((D,B),E),A),C)\")) # Same topology, but shuffled leaves\nnothing # hide","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"Here, pruning the two leaves (A,C) or (D,E) results in compatible trees (resp. ((B,D),E) and ((A,B),C)).    These moves each have a cost 2gamma (removing 2 clades), but bring us from trees with 5 incompatibilities to 0.    They will only be accepted if gamma leq 25. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"  computeMCCs(t1, t2, OptArgs(γ=2))\n  computeMCCs(t1, t2, OptArgs(γ=3))","category":"page"},{"location":"options/#Resolving-trees-with-polytomies","page":"Important options","title":"Resolving trees with polytomies","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"See Resolving","category":"page"},{"location":"options/#likelihood","page":"Important options","title":"Degeneracy: sorting with likelihood","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"When several MCC decompositions are possible, degeneracy is removed by using the likelihood_sort option (activated by default).  In the example below, there are three equivalent decompositions if only topology is considered: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"using TreeKnit # hide\nt1 = node2tree(parse_newick(\"((A:2,B:2):2,C:4)\"))\nt2 = node2tree(parse_newick(\"(A:2,(B:1,C:1):1)\"))\noa = OptArgs(likelihood_sort = false)\nunique([computeMCCs(t1, t2, oa) for rep in 1:50]) # Repeating computation many times ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"When taking branch lengths into account, this degeneracy vanishes: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"oa = OptArgs(likelihood_sort = true)\nunique([computeMCCs(t1, t2, oa) for rep in 1:50])","category":"page"},{"location":"runopt/#The-runopt-function","page":"runopt","title":"The runopt function","text":"","category":"section"},{"location":"runopt/","page":"runopt","title":"runopt","text":"using TreeKnit\nusing TreeKnit.SplitGraph\nusing TreeTools","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"For larger trees, opttrees will not find all reassortments at once.    The reason for this is that it is often necessary to \"clean\" reassorted leaves in smaller clades in order to see other reassortments deeper in the tree.    As a consequence, trees obtained after one round of opttrees will still have incompatibilities.  Below is a relatively simple example of trees for which opttrees does not find all reassorted leaves in one go: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"nwk1 = \"(Z,(G,(((A,X),(B,C)),((D,Y),(E,F)))))\"\nnwk2 = \"(G,((A,(B,(C,X))),((D,(E,(F,Y))),Z)))\"\nt1 = node2tree(parse_newick(nwk1))\nt2 = node2tree(parse_newick(nwk2))\nnothing # hide","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"These trees are constructed in the following way (you're encouraged to draw them!): ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Clade ((A,X),(B,C)) in the first tree \"corresponds\" to clade (A,(B,(C,X))) in the second tree, with X as the reassorted leaf.  Same goes for clades ((D,Y),(E,F)) and (D,(E,(F,Y))). \nWe respectively name these not yet compatible clades ABC and DEF. At a deeper level, the trees are now of the form (Z,(G,(ABC,DEF))) for the first and (G,(ABC,(DEF,Z))) for the second, with Z as the obvious reassorted leaf. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"The important property here is that for a high enough value of gamma, it is only possible for opttrees to see that Z is reassorted if clades ABC and DEF are \"coarse-grained\" to leaves.    In return, this coarse-graining is only possible after X and Y have been identified as reassorted leaves, which will happen after a first iteration of opttrees.     The task of iterating opttrees is performed by the runopt function.    Here, we walk through typical steps it takes.","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Let's do a first pass with opttrees, with gamma=3.     We first build the SplitGraph object, as detailed in the opttrees page. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"treelist = Any[t1, t2]\nmccs_naive = naive_mccs(treelist) # these are just the leaves in this example\nmcc_names = TreeKnit.name_mcc_clades!(treelist, mccs_naive)\nfor (i,t) in enumerate(treelist)\n  treelist[i] = TreeKnit.reduce_to_mcc(t, mccs_naive)\nend\ng = SplitGraph.trees2graph(treelist);\nnothing # hide","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"We then run the simulated annealing optimization to find optimal leaves to remove. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"opt_confs = SplitGraph.sa_opt(g; Trange = reverse(1e-3:1e-2:1), M = 10, γ = 3)[1]\nmccs_found = [mcc_names[x] for x in g.labels[.!opt_confs[1]]]","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"!!! info gamma = 2     If you run this example using gamma leq 2, Z will immediatly be found as a reassorted strain.      It is indeed not easy to find example that combine trees with a small number of leaves (9 here), obvious reassortments, and that are not solved in one go by opttrees with a low value of gamma.      However, when dealing with trees with hundreds of leaves, finding all MCCs in one go is the exception rather than the rule. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"As expected, X Y are found as reassortants.    However, the two trees will still have incompatibilities when removing those two leaves.    To make this explicit, we remove the leaves X and Y and compute naive mccs again. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"TreeKnit.pruneconf!(mccs_found, treelist...) # prune clades in a list of trees. Wrapper around TreeTools.prunesutree!\nmccs_naive = naive_mccs(treelist...)","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Now that X and Y are removed, we see that clades ABC and DEF are common to both trees.    If we reduce the pruned trees to their new naive MCCs again, we now see that Z is an obvious choice for a reassorted strain: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"mcc_names = TreeKnit.name_mcc_clades!(treelist, mccs_naive)\nfor (i,t) in enumerate(treelist)\n  treelist[i] = TreeKnit.reduce_to_mcc(t, mccs_naive)\nend\ntreelist[1]\ntreelist[2]","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"To finish the inference of MCCs, we would now have to re-run the optimization process.    It is now clear that the opttrees has to be iterated.    This is performed automatically by the runopt function.    This process stops when one of the following end conditions is found: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"If no new MCCs are found in a given iteration of opttrees.  This occurs when the optimal configuration resulting from the simulated annealing has all leaves present. \nIf not and new MCCs were found, prune them from the trees.  If the resulting trees do not have any incompatibility.\nIf not, if the maximum number of iterations has been reached.  This can be set through OptArgs, with a default of 15. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"","category":"page"},{"location":"#TreeKnit","page":"Index","title":"TreeKnit","text":"","category":"section"},{"location":"#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"You can simply install TreeKnit using the julia package manager (if you don't have julia, you can get it from here): ","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.add(\"TreeKnit\")","category":"page"},{"location":"","page":"Index","title":"Index","text":"You should now be able to use using TreeKnit from inside julia. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"info: TreeTools package\nIf you are going to use TreeKnit from inside a julia session, you will very likely need the TreeTools package to read Newick tree files in a format that TreeKnit takes as input. You can get TreeTools by typing Pkg.add(\"TreeTools\") from a julia console. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"To use the CLI (Linux/Mac users), build the package by calling ","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.build(\"TreeKnit\")","category":"page"},{"location":"","page":"Index","title":"Index","text":"This will add executable scripts to your ~/.julia/bin folder.  Simply add this folder to your path to call the script, e.g. export PATH=\"$HOME/.julia/bin:$PATH\".  You should now be able to call, e.g., treeknit --help.","category":"page"},{"location":"resolving/#Resolving","page":"Resolving","title":"Resolving","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The lack of resolution in the inference of phylogenetic trees results in polytomies: internal nodes with more than two offsprings.    Polytomies can cause the topology of two trees to differ, which cause problems when inferring reassortments using topological information.    Suppose for instance that we have a first tree (e.g. for a given segment of flu): ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using TreeKnit # hide\nt1 = node2tree(parse_newick(\"(A,(B,C))\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"where we can identify the clade (B,C) because of a mutation in this segment present in B and C but not in A. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"If this mutation does not exist in a second segment, then in the absence of reassortment its tree will look something like this: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t2 = node2tree(parse_newick(\"(A,B,C)\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"As a result, t1 and t2 differ for a reason unrelated with reassortment. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"To overcome this issue, one has to resolve trees as much as possible, typically using the information of one to remove polytomies in the other.    This can only be done if no reassortments are present. ","category":"page"},{"location":"resolving/#Resolving-pairs-of-trees","page":"Resolving","title":"Resolving pairs of trees","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In the example above, it is natural to think that the difference between the two trees is due to a lack of resolution and not to reassortment.    This is because the split (B,C) in the first tree is compatible with the second tree: it is possible to add this split to t2.    What this means is that the difference in topology can be explained by something else than reassortment. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In this case, we can simply resolve t2 by adding each split in t1 with which it is compatible.    If t1 has polytomies, the same could be done to resolve t1 using t2.    This operation is performed by the resolve! function: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using TreeKnit\nt1 = node2tree(parse_newick(\"(A,(B,C))\"))\nt2 = node2tree(parse_newick(\"(A,B,C)\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"new_splits = resolve!(t1, t2);\nt2","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"resolve! returns an array of SplitList objects (of the TreeTools package) containing the new splits introduced in each of the two trees: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"isempty(new_splits[1])\nnew_splits[2]","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"If the resolve option is passed to computeMCCs (through OptArgs), resolve! will be called on each pair of trees before each iteration of the MCC inference procedure. ","category":"page"},{"location":"resolving/#Resolving-during-MCC-inference","page":"Resolving","title":"Resolving during MCC inference","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The above resolving method works fine for simple \"obvious\" cases, where a split in one tree directly resolves a polytomy in another.  However, consider the following case: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using TreeKnit","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t1 = node2tree(parse_newick(\"((A,B),(C,(D,(E,X))))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),(C,D,E))\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"There are now two sources of topological differences between t1 and t2: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The reassorted strain X. \nThe lack of resolution resulted in a polytomy (C,D,E) in t2, which is resolved in t1 in the form of (C,(D,(E,X)) ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The resolve! function is helpless in such cases: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"new_splits = resolve!(t1, t2)\nisempty(new_splits[2])","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Indeed, there is no split in t1 that can directly help us resolve t2.    The closest such split is (D,E,X), but it is incompatible with t2 because of X.    If we knew beforehand that X is reassorted, we could simply ignore it while resolving t2.    The (D,E,X) split in t1 would become (D,E), which is compatible with t2, and the resolve! function would handle this.  ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"However, the topology-based heuristic used by TreeKnit is not able to detect that X is the only reassorted leaf if the trees are not resolved!   Indeed, if we \"remove\" X from the trees, some incompatibilities will remain.    For instance, the split above E will be (D,E) in the first tree and (C,D,E) in the second.    Without resolving, the heuristic will predict a reassortment above almost every leaf: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"computeMCCs(t1, t2, OptArgs(;resolve=false))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In order to achieve progress in this kind of situation, we have to perform two operations at the same time: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"realize that X is the only reassorted strain, and can be ignored when resolving.\nresolve t2 with the (D,E,X) split, ignoring X. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"This is done automatically during MCC inference if the resolve option of OptArgs is given (default):  ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"MCCs = computeMCCs(t1, t2, OptArgs(;resolve=true))","category":"page"},{"location":"resolving/#Resolving-with-inferred-MCCs","page":"Resolving","title":"Resolving with inferred MCCs","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Once the MCCs are inferred, it is possible to use them to resolve trees: in the regions of shared branches of the ARG, the two trees t1 and t2 must have the same splits.    The resolve! function also has a method for this.    Using the example above, we have","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"resolved_splits = resolve!(t1, t2, MCCs)\nt2","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The split (D,E) is now present in t2.  Note that it was not present in t1: only the splits (D,E,X) and (E,X) existed there.  However, since resolve! now knows (A,B,C,D,E) is an MCC, the resolve! function can \"ignore\" leaf X when resolving.   ","category":"page"},{"location":"types/","page":"OptArgs","title":"OptArgs","text":"CurrentModule = TreeKnit","category":"page"},{"location":"types/#The-OptArgs-object","page":"OptArgs","title":"The OptArgs object","text":"","category":"section"},{"location":"types/","page":"OptArgs","title":"OptArgs","text":"computeMCCs and several other functions take an OptArgs object that controls several parameters of the inference process. ","category":"page"},{"location":"types/","page":"OptArgs","title":"OptArgs","text":"OptArgs","category":"page"},{"location":"types/#TreeKnit.OptArgs","page":"OptArgs","title":"TreeKnit.OptArgs","text":"struct OptArgs\n\nStoring parameters for SplitGraph.runopt function.\n\nGeneral\n\nγ::Real = 2\nitmax::Int64 = 15: maximal number of iterations of naive MCCs / SA cycles.\nlikelihood_sort::Bool = true: sort equivalent configurations using likelihood test based on branch length.\nresolve::Bool = true: try to resolve trees while finding MCCs.\nseq_lengths: lengths of sequences that trees were built from. Used in likelihood calculations. This is initialized from other input arguments, and defaults to sequences of length one.\n\nSimulated annealing\n\nnMCMC::Int = 25: The number of MCMC iterations for a tree of n leaves is nMCMC*n.\ncooling_schedule = :geometric: type of cooling schedule (:geometric, :linear, :acos)\nTmin::Float64 = 0.05: minimal temperature of SA.\nTmax::Float64 = 0.8: maximal temperature of SA.\nnT::Int = 3000: number of steps in the cooling schedule\n\nVerbosity\n\nverbose::Bool=false: first level of verbosity\nvv::Bool = false: second level of verbosity\n\n\n\n\n\n","category":"type"}]
}
