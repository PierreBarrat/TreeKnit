<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · TreeKnit documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TreeKnit documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li class="is-active"><a class="tocitem" href>Overview</a><ul class="internal"><li><a class="tocitem" href="#Using-the-CLI"><span>Using the CLI</span></a></li><li><a class="tocitem" href="#Using-from-a-Julia-session"><span>Using from a Julia session</span></a></li></ul></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li><li><a class="tocitem" href="../multitreeknit/">MultiTreeKnit</a></li><li><a class="tocitem" href="../visualization/">Visualizing MCCs</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">Objects</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/TreeKnit.jl/blob/master/docs/src/overview.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h1><h2 id="Using-the-CLI"><a class="docs-heading-anchor" href="#Using-the-CLI">Using the CLI</a><a id="Using-the-CLI-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-CLI" title="Permalink"></a></h2><p><code>TreeKnit</code> offers a simple CLI script: <code>treeknit</code>.  It takes two or more trees as input, passed as <a href="https://en.wikipedia.org/wiki/Newick_format">Newick</a> files, and infers reassortment events between all <em>pairs</em> of trees.  It does this by finding shared regions of two trees, so called <a href="../mccs/#MCCs">maximally compatible clades (MCCs)</a>, within which we assume no reassortment has occurred.  Each MCC corresponds to one reassortment event between the two trees. </p><p>When exactly two trees are given as input, TreeKnit additionally returns an Ancestral Reassortment Graph (ARG) that combines the two trees.  This is currently not possible for multiple trees, more information on how <code>TreeKnit</code> runs on more than two trees can be found in the <a href="../multitreeknit/#multitreeknit">MultiTreeKnit section</a>).</p><div class="admonition is-info"><header class="admonition-header">Compile time</header><div class="admonition-body"><p>Julia is compiled <em>just in time</em>, meaning that functions are compiled when called for the first time inside a julia session. For this reason, some compilation will take place each time the  <code>treeknit</code> script is called, leading to an overhead of a few seconds. If <code>Treeknit</code> is to be applied to many pairs of trees, it will be faster to use it from a Julia session. </p></div></div><h3 id="Input"><a class="docs-heading-anchor" href="#Input">Input</a><a id="Input-1"></a><a class="docs-heading-anchor-permalink" href="#Input" title="Permalink"></a></h3><p>Inputs to <code>treeknit</code> are files containing trees in Newick format.  The only strict condition on the trees is that they share their leaf nodes.  Example: </p><pre><code class="nohighlight hljs">treeknit tree1.nwk tree2.nwk</code></pre><p>There are other important requirements for input trees, highlighted below.  They are not strict conditions in the sense that the algorithm will not fail if they are not met.  However, not meeting them might result in irrelevant or meaningless output. </p><div class="admonition is-warning"><header class="admonition-header">Insignificant branches</header><div class="admonition-body"><p>Tree builders sometimes introduce branches of insignificant length in order to resolve polytomies and obtain binary trees. Since <code>TreeKnit</code> relies on topological differences between trees, and all internal nodes of input trees are interpreted as hard topological constraints. It is therefore important to remove low support branches/internal nodes prior to passing the trees to <code>treeknit</code>. This is most easily done by removing every branch that is not supported by at least one mutation, <em>e.g.</em> branches shorter than <span>$(L/2)^{-1}$</span>, where <span>$L$</span> is the length of the sequences. Additionally, internal nodes with a low bootstrap value (typically <span>$&lt;75$</span>) can be remove for additional robustness. </p></div></div><div class="admonition is-warning"><header class="admonition-header">Rooting the trees</header><div class="admonition-body"><p><code>TreeKnit</code> depends on how the trees are rooted. It is important that the two trees are rooted in a consistent way. We recommend using the same outgroup for rooting both trees.</p></div></div><h3 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h3><p>Output of the inference is written to the directory <code>treeknit_results</code>. This can be changed using the <code>--outdir</code> option.    The directory will contain:    </p><ul><li>the MCCs, <em>i.e.</em> shared regions for paris of trees. The MCCs of all tree pairs are written in JSON format.  The example below shows possible MCCs for three trees of 10 leaves named <code>a</code>, <code>b</code> and <code>c</code>. </li></ul><pre><code class="nohighlight hljs">{ 
    &quot;MCC_dict&quot; : {
        &quot;1&quot;: { 
            &quot;trees&quot;:[&quot;a&quot;, &quot;b&quot;],
            &quot;mccs&quot;: [[&quot;5_0&quot;, &quot;6_0&quot;],[&quot;10_0&quot;, &quot;1_0&quot;, &quot;2_0&quot;, &quot;3_0&quot;, &quot;4_0&quot;, &quot;7_0&quot;, &quot;8_0&quot;, &quot;9_0&quot;]]
            },
        &quot;2&quot;: { 
            &quot;trees&quot;:[&quot;a&quot;, &quot;c&quot;],
            &quot;mccs&quot;: [[&quot;1_0&quot;, &quot;8_0&quot;, &quot;9_0&quot;],[&quot;10_0&quot;, &quot;2_0&quot;, &quot;3_0&quot;, &quot;4_0&quot;, &quot;5_0&quot;, &quot;6_0&quot;, &quot;7_0&quot;]]
            },
        &quot;3&quot;: { 
            &quot;trees&quot;:[&quot;b&quot;, &quot;c&quot;],
            &quot;mccs&quot;: [[&quot;5_0&quot;, &quot;6_0&quot;],[&quot;1_0&quot;, &quot;8_0&quot;, &quot;9_0&quot;],[&quot;10_0&quot;, &quot;2_0&quot;, &quot;3_0&quot;, &quot;4_0&quot;, &quot;7_0&quot;]]
        }
    }
}</code></pre><ul><li>resolved trees: polytomies in each tree can be resolved using information coming from the other trees and from the MCCs (see the <a href="../resolving/#resolving">resolving section</a>) They are written to files with the label <code>_resolved</code> added behind the original tree file name, e.g. <code>tree_ha_resolved.nwk</code>. </li><li>a file with all parameters used by TreeKnit during inference titled <code>parameters.json</code>.</li></ul><p>In addition, when TreeKnit is called on exactly two trees the directory will contain a separate ARG folder with:</p><ul><li>the ARG, written as an extended <a href="https://doi.org/10.1186/1471-2105-9-532">Newick string</a>.    </li><li>liberally resolved trees needed for the construction of an ARG, see <a href="../resolving/#resolve_strict_vs_liberal">resolving section</a>. The output will be written to a file with the label <code>_liberal_resolved</code> added behind the tree label, e.g. <code>tree_ha_liberal_resolved.nwk</code>. </li><li>a table with the correspondence between internal nodes of the ARG and the trees. Note that this refers to node labels of the liberally resolved trees, which may not be the same as the ones given as input.   </li></ul><h3 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h3><p>We present two methods for running TreeKnit, however it is possible to specify all parameters combinations for each individual use-case.</p><h4 id="TK_method_options"><a class="docs-heading-anchor" href="#TK_method_options">TreeKnit run methods</a><a id="TK_method_options-1"></a><a class="docs-heading-anchor-permalink" href="#TK_method_options" title="Permalink"></a></h4><ul><li><code>--better-trees</code>: This method is recommended for most users using &gt;2 trees and is also the fastest. It will attempt to resolve all trees compatibly before inferring MCCs, it will then run 1 round of pair-wise treeknit inference on all tree pairs individually - not further resolving trees. This technique has been optimized for sensitivity in MCC inference and polytomy resolution, minimizing the false positive rate for shared branches and new splits, but increasing the false negative rate, i.e. typically inferring too many reassortment events. </li><li><code>--better-MCCs</code>: This method is recommended for users using 2 trees, or users who are more interested in inferring accurate MCCs. It will also attempt to resolve all trees compatibly before inferring MCCs, it will then run 1 round of sequential treeknit inference on all tree pairs, further resolving trees using the MCCs inferred in the previous treeknit calls. </li></ul><p>For <span>$K&gt;2$</span> trees it will then run one final round of pairwise TreeKnit on all tree pairs individually - not further resolving trees (this is required for <span>$K&gt;2$</span> trees to ensure the accuracy of the output MCCs). This technique is optimized for MCC accuracy, however the output trees will potentially have a higher rate of inaccurate splits, this rate will increase with the number of trees. If more than 2 trees are given as input it will one run one last round of <span>$TreeKnit$</span> on all tree pairs without resolution.</p><p>Options that you can play with are:  </p><ul><li><code>--gamma</code> or <code>-g</code>: the parsimony parameter <span>$\gamma$</span> (see <a href="../options/#gamma">here</a>).</li><li><code>--naive</code>: naive inference. Using this flag is equivalent to setting <span>$\gamma \rightarrow \infty$</span>.  </li><li><code>--seq-lengths</code>: length of sequences used to infer trees. These are used for likelihood tests to break degeneracy between topologically equivalent MCCs.  </li><li><code>--no-likelihood</code>: do not use branch length to sort the likelihood of different MCCs.</li><li><code>--no-resolve</code>: do not attempt to resolve trees during and after tree-pair MCC inference.</li><li><code>--parallel</code>: run sequential <a href="../multitreeknit/#multitreeknit">MultiTreeKnit</a> with parallelization (only used for 3 or more trees).</li><li><code>--auspice-view</code>: will create files that can be used to view a tanglegram of the two trees with colored maximally compatible clades in <a href="https://docs.nextstrain.org/projects/auspice/en/stable/advanced-functionality/second-trees.html">auspice</a>. For more information see <a href="../visualization/#view_auspice">Visualization of MCCs in a tanglegram</a>.</li><li><code>--verbosity-level</code>: see the <a href="../options/#Verbosity">verbosity</a> section for information. </li></ul><p>Additional options can be used for &quot;advanced users&quot;:</p><ul><li><code>rounds</code>: number of rounds of TreeKnit. Trees are resolved in each TreeKnit run (except in the final round when there are more than 2 trees, the <code>--resolve-all-rounds</code> can be used to modify this behavior), meaning subsequent rounds can give different results. This is especially useful for more than two trees, see <a href="../multitreeknit/#multitreeknit">MultiTreeKnit</a>.</li><li><code>--no-pre-resolve</code>: do not compatibly resolve all trees with each other before inferring MCCs (default is to pre-resolve).</li><li><code>--resolve-all-rounds</code>: resolve trees before inferring pairwise MCCs in all rounds Overrides <code>--no-resolve</code>. Default for 2 trees. For more than 2 trees the default is to not resolve in the final round.</li><li><code>--liberal-resolve</code>: use liberal resolving method, see <a href="../resolving/#resolve_strict_vs_liberal">here</a>. In short, with this option, TreeKnit will try to resolve trees as much as possible even in ambiguous situations. It results in more resolved trees but also more wrong splits. </li></ul><p>More details on the options can be found throughout the documentation.  In particular, the parsimony parameter is explained <a href="../options/#gamma">here</a> and resolution of trees <a href="../resolving/#resolving">here</a>.</p><h2 id="Using-from-a-Julia-session"><a class="docs-heading-anchor" href="#Using-from-a-Julia-session">Using from a Julia session</a><a id="Using-from-a-Julia-session-1"></a><a class="docs-heading-anchor-permalink" href="#Using-from-a-Julia-session" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">For two trees only</header><div class="admonition-body"><p>For more than two trees, the process is different. A plan for the future is to &quot;uniformize&quot; the way TreeKnit is called for 2 or more trees. So what&#39;s below may be deprecated then. </p></div></div><p>If <code>TreeKnit</code> has to be used on several datasets and speed is important, then you should call it from a julia session directly.  Let&#39;s see how one does this for a simple two tree example using the <code>example</code> directory, which contains two Newick files <code>tree_h3n2_ha.nwk</code> and <code>tree_h3n2_na.nwk</code>. We shall use the <code>--better-MCCs</code> method, which is the default for 2 trees. First, read the trees: </p><pre><code class="language- hljs">using TreeTools
using TreeKnit
t_ha = read_tree(dirname(pathof(TreeKnit)) * &quot;/../examples/tree_h3n2_ha.nwk&quot;, label=&quot;ha&quot;)
t_na = read_tree(dirname(pathof(TreeKnit)) * &quot;/../examples/tree_h3n2_na.nwk&quot;, label=&quot;na&quot;)</code></pre><div class="admonition is-info"><header class="admonition-header">Tree Labels</header><div class="admonition-body"><p>When computing the MCCs for tree pairs <code>TreeKnit</code> uses a tree&#39;s <code>label</code> as a unique identifier. These labels are also written to the output <code>MCCs.json</code> file. When <code>TreeKnit</code>is used via the command line the filename and/or folder name is used as a label for the input trees if these are unique, otherwise an error is thrown. When using <code>TreeKnit</code> from a julia session, trees will be assigned a random unique string as an identifying label. One can change this by calling <code>label!(tree, some_label)</code>, see the <a href="https://pierrebarrat.github.io/TreeTools.jl/dev/">TreeTools documentation</a> </p></div></div><p>We run treeknit in the repl using the command: <code>run_treeknit!</code> (it takes an optional argument object <code>OptArgs</code>, with which we can specify inference parameters) the command does the following:</p><ol><li>By default, <code>TreeKnit</code> resolves all trees with each other prior to inference unless <code>--no-pre-resolve</code> is activated (equivalent to setting <code>pre_resolve=false</code> in the <code>OptArgs</code>). </li><li>Compute the MCCs of the two trees, by default MCCs are inferred up to resolution, this can be deactivated with the <code>--no-resolve</code> flag (equivalent to setting <code>resolve=false</code> in the <code>OptArgs</code>). See <a href="../mccs/#MCCs">MCCs</a> for more details.</li><li>Resolve the two trees using the inferred MCCs. This can also be deactivated with the <code>--no-resolve</code> flag. </li><li>Ladderize the first input tree, and sort the polytomies of two trees w.r.t to the MCCs, allowing for </li></ol><p>clearer <a href="../visualization/#visualization">Visualization</a> (e.g. tanglegrams).</p><div class="admonition is-info"><header class="admonition-header">pre-resolve and resolve</header><div class="admonition-body"><p>Note that<code>resolve=true</code> will also resolve trees with each other prior to inference, and thus <code>pre_resolve</code> is not needed for 2 trees if <code>resolve=true</code>, but we distinguish between the two options for consistency with with <span>$K&gt;2$</span> tree-case.</p></div></div><p>For two trees we can additionally compute the ARG from the resolved trees and the MCCs, note ARG reconstruction will potentially further resolve trees, adding ambiguous splits in a manner that is more parsimonious, using <a href="../resolving/#resolve_strict_vs_liberal">liberal resolution</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; MCCs = run_treeknit!(t_ha, t_na, OptArgs(;pre_resolve=true, resolve=true, strict=true)) # compute MCCs, resolve trees</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: OptArgs not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; arg, rlm, lm1, lm2 = SRG.arg_from_trees(t_ha, t_na, MCCs.mccs[Set([&quot;ha&quot;, &quot;na&quot;])]); # compute the ARG and mappings from tree to ARG internal nodes.</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: SRG not defined</code></pre><p>To write these results to files, use the following commands: </p><pre><code class="nohighlight hljs">write(&quot;arg.nwk&quot;, arg) # write the ARG
write_mccs(&quot;MCCs.json&quot;, MCCs) # write the MCCs
write_newick(&quot;tree_ha_ARG_resolved.nwk&quot;, t_ha) # write resolved HA tree</code></pre><p>Note that the <code>treeknit</code> function in <code>src/cli.jl</code> follows exactly these steps for two trees, for multiple trees see the <a href="../multitreeknit/#multitreeknit">MultiTreeKnit section</a>. Have a look at it for a more detailed example of how to use this package from inside julia. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Index</a><a class="docs-footer-nextpage" href="../mccs/">MCCs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 26 January 2023 14:46">Thursday 26 January 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
